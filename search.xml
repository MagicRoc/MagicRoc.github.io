<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python装饰器记录总结]]></title>
      <url>%2F2017%2F04%2F10%2FPython%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AE%B0%E5%BD%95%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[装饰器是一个函数,一个用来包装函数的函数，装饰器在函数申明（不需要调用）完成的时候被调用，调用之后返回一个修改之后的函数对象，将其重新赋值原来的标识符，并永久丧失对原始函数对象的访问。对某个方法应用了装饰方法后， 其实就改变了被装饰函数名称所引用的函数代码块入口点，使其重新指向了由装饰方法所返回的函数入口点。 无参数装饰器-包装无参数函数这是一个打印log的decorator，此时输出了函数名、返回值、运行时间。 import time from functools import wraps def log(func): @wraps(func) def wrapper(): print(&quot;function runing&quot;) ts = time.time() result = func() te = time.time() print(&quot;function = {0}&quot;.format(func.__name__)) print(&quot; return = {0}&quot;.format(result)) print(&quot; time = %.6f sec&quot; % (te - ts)) return wrapper @log def sum(): x = 1 y = 2 return x + y sum() 运行结果: function runing function = sum return = 3 time = 0.000001 sec 代码中在sum函数上一行添加@log相当于执行了语句: sum = log(sum) 由于log()是一个decorator，返回一个函数，所以，原来的sum()函数仍然存在，只是现在同名的sum变量指向了新的函数，于是调用sum()将执行新函数，即在log()函数中返回的wrapper()函数 无参数装饰器-包装有参数函数import time from functools import wraps def log(func): @wraps(func) def wrapper(*args, **kwargs): # 接受传入的参数 print(&quot;function runing&quot;) ts = time.time() result = func(*args, *kwargs) # 函数使用传入的参数 te = time.time() print(&quot; function = {0}&quot;.format(func.__name__)) print(&quot;arguments = {0} {1}&quot;.format(args, kwargs)) print(&quot; return = {0}&quot;.format(result)) print(&quot; time = %.6f sec&quot; % (te - ts)) return wrapper @log def sum(x,y): return x + y sum(1,2) 运行结果： function runing function = sum arguments = (1, 2) return = 3 time = 0.000004 sec 带参数装饰器 – 包装无参数函数import time from functools import wraps def log(name): def decora(func): @wraps(func) def wrapper(): print(&quot;name : {0}&quot;.format(name)) print(&quot;function runing&quot;) ts = time.time() result = func() te = time.time() print(&quot; function = {0}&quot;.format(func.__name__)) print(&quot; return = {0}&quot;.format(result)) print(&quot; time = %.6f sec&quot; % (te - ts)) return wrapper return decora @log(&apos;MagicRoc&apos;) def sum(): x = 1 y = 2 return x + y sum() 运行结果: name : MagicRoc function runing function = sum return = 3 time = 0.000002 sec 此时代码中在sum函数上一行添加@log(‘MagicRoc’)相当于执行了语句: sum = log(&apos;MagicRoc&apos;)(sum) 首先执行log(‘MagicRoc’)，返回的是decorator函数，再调用返回的函数，参数是sum函数，返回值最终是wrapper函数。 不同在于：比上一层多了一层封装，先传递参数，再传递函数名 带参数装饰器 – 包装有参数函数import time from functools import wraps def log(name): def decora(func): @wraps(func) def wrapper(*args, **kwargs): print(&quot;name : {0}&quot;.format(name)) print(&quot;function runing&quot;) ts = time.time() result = func(*args, **kwargs) te = time.time() print(&quot; function = {0}&quot;.format(func.__name__)) print(&quot;arguments = {0} {1}&quot;.format(args, kwargs)) print(&quot; return = {0}&quot;.format(result)) print(&quot; time = %.6f sec&quot; % (te - ts)) return wrapper return decora @log(&apos;MagicRoc&apos;) def sum(x,y): return x + y sum(1,2) 运行结果： name : MagicRoc function runing function = sum arguments = (1, 2) {} return = 3 time = 0.000002 sec 多个Decroratorfrom functools import wraps def div(cla): def decara(func): @wraps(func) def wrapper(*args,**kwargs): return &quot;&lt;div class = %s &gt; %s &lt;/div&gt;&quot; % (cla, func()) return wrapper return decara def h1(cla): def decara(func): @wraps(func) def wrapper(*args,**kwargs): return &quot;&lt;h1 class = %s &gt; %s &lt;/h1&gt;&quot; % (cla,func()) return wrapper return decara @div(&apos;divclass&apos;) @h1(&apos;h1class&apos;) def hello(): return &apos;hello world&apos; print( hello()) 装饰器的顺序很重要: @A @B @C def f (): 等价于: f = A(B(C(f))) 代码运行过程中中hello先指向了h1中的wrapper，又指向了div中的wrapper。h1中的func指向的是要修饰的函数本身，而div中的func指向的是h1中的wrapper函数。 装饰器类from functools import wraps import time class log(object): def __init__(self,name): self.name = name def __call__(self,func): @wraps(func) def wrapper(*args, **kwargs): print(&quot;name : {0}&quot;.format(self.name)) print(&quot;function runing&quot;) ts = time.time() result = func(*args, **kwargs) te = time.time() print(&quot; function = {0}&quot;.format(func.__name__)) print(&quot;arguments = {0} {1}&quot;.format(args, kwargs)) print(&quot; return = {0}&quot;.format(result)) print(&quot; time = %.6f sec&quot; % (te - ts)) return wrapper @log(&apos;MagicRoc&apos;) def sum(): x = 1 y = 2 return x + y sum() 将装饰器定义为类的一部分用类方法作为装饰器函数和普通函数作为装饰器函数极其相似 from functools import wraps class A: def decorator(self, func): @wraps(func) def wrapper(*args, **kwargs): return func(*args, **kwargs) return wrapper 使用的时候： a = A() @a.decorator def fun(): pass Flask 通过URL的路由来调用相关注册的函数就是将装饰器定义为类的一部分 理解Flask 路由注册回调函数class MyApp(): def __init__(self): self.func_map = {} def register(self, name): def func_wrapper(func): self.func_map[name] = func return func return func_wrapper def call_method(self, name=None): func = self.func_map.get(name, None) if func is None: raise Exception(&quot;No function registered against - &quot; + str(name)) return func() app = MyApp() @app.register(&apos;/&apos;) def main_page_func(): return &quot;This is the main page.&quot; @app.register(&apos;/next_page&apos;) def next_page_func(): return &quot;This is the next page.&quot; print app.call_method(&apos;/&apos;) print app.call_method(&apos;/next_page&apos;) 因为这里是带参数的装饰器，所以比之前的要多一层嵌套，最外层的接受参数，其次层的接受函数参数。这里知识把url和对应的回调函数记录在url_map中，所以原样返回原函数就好。就不用定义第三个需要返回的函数了 关于整篇文章的wraps装饰器被decorator的函数其实已经是另外一个函数了，在打印log的例子中，sum函数指向的已经是wrapper函数了，所以输出sum.__name__的值不是sum而是wrapper。不需要编写wrapper.__name__ = func.__name__这样的代码。直接使用wraps装饰器就可以消除这个问题 参考链接： http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318435599930270c0381a3b44db991cd6d858064ac0000 http://coolshell.cn/articles/11265.html http://www.wklken.me/posts/2012/10/27/python-base-decorator.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flask+uWSGI+Nginx部署笔记]]></title>
      <url>%2F2017%2F04%2F05%2FFlask-uWSGI-Nginx%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[其实简单部署Flask程序很简单，只要掌握了流程和每一层的作用。本来应该再加上Supervisor，不过我还没有尝试，先总结下来uWSGI和Nginx以及遇到的一些小问题以及解决办法 环境 本地环境：Ubuntu16.04 服务器：Centos7.0 Python: 2.7.5 安装SSHsudo apt-get install openssh-server 编辑配置文件sudo vi /etc/ssh/sshd_config 禁用：PermitRootLogin prohibit-password添加：PermitRootLogin yes 重启 sudo service ssh restart ssh使用ssh root@远程服务器IP scp使用scp: 跨机远程拷贝 从本地到远程服务器scp 本地文件 远程服务器用户名@远程服务器IP:远程服务器目录 从远程服务器下载到本地scp 远程服务器用户名@远程服务器IP:远程服务器文件 本地目录 如果是目录则在scp后加-r参数即可 配置Flask安装pipsudo yum –y install epel-release sudo yum –y install python-pip 安装virtualenvpip install virtualenv 在应用程序目录创建虚拟环境 virtualenv venv激活虚拟环境: source /venv/bin/activate 安装flask应用程序依赖包因为pip安装时速度太慢，所以决定更改为pip国内源对指定包对安装临时使用豆瓣源 pip install flask_sqlalchemy –i http://pypi.douban.com/simple 永久更新源办法 修改配置文件在主目录下创建.pip文件夹 mkdir ~/.pip 然后在该目录下创建pip.conf文件 vim pip.conf 写入以下内容 [global] trusted-host = pypi.douban.com index-url = http://pypi.douban.com/simple 安装Nginxsudo yum install nginx 配置Nginxvim etc/nginx/nginx.conf 修改如下 server { listen 80; server_name XXX.XXX.XXX; #公网地址 location / { include uwsgi_params; uwsgi_pass 127.0.0.1:8001; # 指向uwsgi 所应用的内部地址,所有请求将转发给uwsgi 处理 uwsgi_param UWSGI_PYHOME /root/School/venv; # 指向虚拟环境目录 uwsgi_param UWSGI_CHDIR /root/School; # 指向网站根目录 uwsgi_param UWSGI_SCRIPT manage:app; # 指定启动程序 } } Nginx简单指令 启动nginx： 命令行输入nginx或者nginx -c nginx配置文件 关闭nginx：ps -ef|grep nginx查看nginx 线程IDkill -QUIT 线程ID Nginx出现413 Request Entity Too Large错误解决方法打开nginx主配置文件nginx.conf,找到http{}段，修改或者添加 client_max_body_size 4m; 安装uWSGI需安装三个库: 1.sudo yum install libxml2 2.sudo yum install gcc 3.sudo yum install python-devel 然后: pip install uwsgi 配置uWSGI进入flask应用程序目录 vim config.ini 编辑: [uwsgi] # uwsgi 启动时所使用的地址与端口 socket = 127.0.0.1:8001 # 指向网站目录 chdir = /root/School # python 启动程序文件 wsgi-file = manage.py # python 程序内用以启动的 application 变量名 callable = app # 处理器数 processes = 4 # 线程数 threads = 2 #状态检测地址 stats = 127.0.0.1:9191 uWSGI命令uwsgi 启动 ：虚拟环境下uwsgi config.iniuwsgi 关闭：虚拟环境下killall -9 uwsgi 部署说明 uWSGI 提高并发访问支持，提高服务运行稳定性 Nginx在这里最基本的一个用处就是转发：当客户访问一个域名或者IP时 Nginx就将访问转发给uwsgi处理 Supervisor可以同时启动多个应用，更重要的是，当某个应用Crash的时候，它可以自动重启该应用，保证可用性 这样uwsgi可以让supervisor帮助启动，而且当uwsgi Crash时会尝试帮重启它，保证uwsgi和网站的可用性 如何理解Nginx, WSGI, Flask之间的关系 ? 这是一篇很好的文章 http://blog.csdn.net/lihao21/article/details/52304119]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Everymail自动邮件的设计与实现]]></title>
      <url>%2F2017%2F03%2F24%2FEverymail%E8%87%AA%E5%8A%A8%E9%82%AE%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[很简单的一个python写的程序，每天早晨六点自动发送邮件到指定邮箱，邮件内容包括当地天气、笑话、英语单词。天气和笑话通过调用API，英语单词通过文件读取 首先实现邮件发送通过email 和 smtplib实现,需要导入的库 from email import encoders from email.header import Header from email.mime.text import MIMEText from email.utils import parseaddr, formatadd import smtplib 设置邮箱表标题，发件人，收件人，以及邮箱内容 msg = MIMEText(location+temp+weather+weatime+jokeall+jokeword, &apos;plain&apos;,&apos;utf-8&apos;) msg[&apos;From&apos;] = _format_addr(&apos;Everymail &lt;%s&gt;&apos; % from_addr) msg[&apos;To&apos;] = _format_addr(&apos;管理员 &lt;%s&gt;&apos; % to_addr) msg[&apos;Subject&apos;] = Header(&apos;The New day&apos;, &apos;utf-8&apos;).encode() 生成实例，登录发送 server = smtplib.SMTP(smtp_server, 25) server.set_debuglevel(1) server.login(from_addr, password) server.sendmail(from_addr, [to_addr], msg.as_string()) server.quit() 接下的只要任务是获取MIMEText中的那些参数location ：当地位置temp：当地温度weather：当地天气weatime：天气更新时间jokeword：十个单词jokeall：一个笑话 天气的获取程序调用的是心知天气的API def fetchWeather(): location = getLocation() result = requests.get(API, params={ &apos;key&apos;: KEY, &apos;location&apos;: location, &apos;language&apos;: LANGUAGE, &apos;unit&apos;: UNIT }, timeout=100) values = json.loads(result.text) results = values[&quot;results&quot;][0] wea = results[&quot;now&quot;] time = re.sub(r&apos;([\d|-]+)T([\d|:]+).+&apos;, r&apos;\1 \2&apos;, results[&quot;last_update&quot;]) return wea,time 通过json.loads将返回的json数据解析，然后一层一层的取出，天气，温度，和时间。因为返回的时间格式一点不适合查看，故用正则将其转化为常见的时间格式 笑话的获取程序调用的是来福岛的笑话接口 def fetchjoke(): showapi_appid = id #替换此值 showapi_sign = key #替换此值 url=&quot;http://route.showapi.com/341-1&quot; send_data = parse.urlencode([ (&apos;showapi_appid&apos;, showapi_appid) ,(&apos;showapi_sign&apos;, showapi_sign) ,(&apos;time&apos;, &quot;&quot;) ,(&apos;page&apos;, &quot;&quot;) ,(&apos;maxResult&apos;, &quot;&quot;) ]) req = request.Request(url) with request.urlopen(req, data=send_data.encode(&apos;utf-8&apos;)) as f: str_res= f.read().decode(&apos;utf-8&apos;) json_res=json.loads(str_res) a = 1 joketitle = [] jokecontext = [] jokeall = &quot;&quot; for i in json_res[&apos;showapi_res_body&apos;].get(&quot;contentlist&quot;): joketitle.append(i[&quot;title&quot;]) jokecontext.append(i[&quot;text&quot;]) jokeall = jokeall + &apos;标题 : &apos; + i[&quot;title&quot;] + &apos;\n&apos; jokeall = jokeall + &apos;内容 : \n&apos; + i[&quot;text&quot;] + &apos;\n\n&apos; a+=1 break return(jokeall) 也是通过json.loads解析返回的json数据，然后取出所需要的数据，作为函数返回数据 单词的获取单词是从一个txt文件按顺序读取的，之前把四级单词全部复制进去。但是有时候程序可能crash，重新启动程序的时候可能又要从第一个单词开始读取了，所以又多了一个文件用来记录每次读取的位置 def fetchword(): theword = &quot;&quot; with open(&apos;value.txt&apos;,&quot;r&quot;) as f1,open(&apos;recoad.txt&apos;,&quot;r&quot;) as f2: flag = f2.read() count = 1 for i in f1: count+=1 if (count &gt;= int(flag)): theword = theword + str(i) + &quot;\n&quot;; if(count == int(flag)+10): break with open(&quot;recoad.txt&quot;,&quot;w&quot;) as f: f.write(str(int(flag)+10)) return theword 定时发送import threading import time from sendmail import send def outosend(): send() global t #Notice: use global variable! t = threading.Timer(86400.0, outosend) # 定时器 t.start() t = threading.Timer(5.0, outosend) while 1: if time.localtime()[3] == 6: # 判断现在是不是早晨六点 t.start() break # 线程不能重复开始，不然会有警告 通过Timer定时器实现每86400秒（一天）发送一次，通过递归实现程序一直运行此函数。但是为了保证在六点发送，然后下一次发送也是六点，所有通过time.localtime判断现在的时间是不是到六点，一旦正确，线程开始启动 同时发送多个邮箱为了保证同时发送多个邮箱，所以把要发送的邮箱写入了文件，然后通过文件一个一个的读取 with open(&quot;emails.txt&quot;,&quot;r&quot;) as f: emails = f.readlines() for to_addr in emails: msg[&apos;To&apos;] = _format_addr(&apos;管理员 &lt;%s&gt;&apos; % to_addr)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python爬虫初探（二）]]></title>
      <url>%2F2017%2F03%2F13%2FPython%E7%88%AC%E8%99%AB%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[相对于系列一做了一些简单的改进，主要是由于科四有图片和动图之分，并且有时候程序会暂停，但不报错，所以一直在想断点继续问题，当然效率依旧低。见谅 同时爬取图片和动图问题因为科目四有的题目包含动图，要爬取的网站是做成mov格式的短视频例如： &lt;div class=&quot;test-r f-r&quot;&gt; &lt;video src=&quot;http://www.jiazhao.com/images/tiku/201511231357033827.mov&quot; controls=&quot;controls&quot;&gt;您的浏览器不支持不放&lt;/video&gt;&lt;!-- &lt;a href=&quot;javascript:;&quot; class=&quot;t-big&quot;&gt;点击放大观看&lt;/a&gt; --&gt; 增加获取视频链接系列一获取图片的方法是在获取选项、答案的基础上再次传到BeautifulSoup对象，然后再次提取img标签，如果某题没有图片，提取的则是一个空值，此处提取img和video标签。如果某题没有图片或视频，提取的则是一个空值。只需改一句代码 img = soup.find_all([&apos;img&apos;,&apos;video&apos;]) 获取图片或动图后缀系列一中为了方便直接在文件名后面加的字符串形式.png后缀，但是现在要解决后缀不一致（写代码尽可能还是不要偷懒…）解决代码： if img: for im in img: src = im.get(&apos;src&apos;) suffix = src.split(&apos;.&apos;)[3] filename = str(i) + &apos;.&apos; + suffix 如果此题有图片或动图，则把这个图的链接通过’.’进行分割。最后的元素则是后缀 争取实现断点继续不知道为什么程序会暂停不动，模仿浏览器，捕获异常都试了，依然不行，所以我尽可能的实现断点继续。每个图片对应一个链接，难免有一个链接卡住（我猜测的） 解决办法 : 在我们得到链接，并生成文件名后，先不去打开这个这个链接，先根据文件名判断这个图片是否文件夹中已经包含，如果包含扔掉这个链接，去继续下一个链接 if img: for im in img: src = im.get(&apos;src&apos;) suffix = src.split(&apos;.&apos;)[3] filename = str(i) + &apos;.&apos; + suffix if os.path.exists(&apos;picture/&apos;+filename): break saveImg(im.get(&apos;src&apos;),filename) 题目解析的爬取思路 1.将所以题目的解析链接爬取出去单独存放到一个文件。 2.为了解决有些链接一次进不去必须中断程序再次开始，和存储图片思路一样，争取实现断点继续， 3.但是写入文件和保存图片还是不一样，针对面临的情况，初步解决想法为每抽取一条链接的解析，就删掉这个链接，用列表存储从链接文件中读取的链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python爬虫初探（一）]]></title>
      <url>%2F2017%2F03%2F12%2FPython%E7%88%AC%E8%99%AB%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[最近参与了的一个项目，因为项目需要驾照考试科一和科四的完整题库，网上找了好久找不到完整版题库，所以才有了这篇博客的由来，因为技术不太好，之前学习的又是Python web相关的知识，所以关于程序的代码可能有些繁琐、低效。见谅 分析得到标题、选项和答案首先看一下要爬取的网页源码内容，科目一共有四章，第一章有30页，每页二十道题，这是第一章第一页的第一题 &lt;a href=&quot;/tiba/9294/&quot; target=&quot;_blank&quot;&gt; &lt;div class=&quot;ui-test clearfix titem&quot;&gt; &lt;p class=&quot;title&quot;&gt;1、&amp;nbsp;如图所示，A车在此处停车是可以的。&lt;/p&gt; &lt;!--判断--&gt; &lt;div class=&quot;test-bd f-l&quot;&gt; &lt;ul&gt; &lt;li&gt;A、正确&lt;/li&gt; &lt;li&gt;B、错误&lt;/li&gt; &lt;li class=&quot;answer&quot;&gt;&lt;strong class=&quot;right&quot;&gt;答案：&lt;/strong&gt; &lt;strong&gt;对&lt;/strong&gt;&lt;span style=&quot;margin-left:100px;display:inline-block;&quot;&gt;查看分析&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;test-r f-r&quot;&gt; &lt;img src=&quot;http://www.jiazhao.com/images/tiku/1436112505.png&quot; &gt;&lt;!-- &lt;a href=&quot;javascript:;&quot; class=&quot;t-big&quot;&gt;查看大图&lt;/a&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/a&gt; 获取标题思考 利用urllib.request.urlopen获取网页HTML内容 将HTML内容传到BeautifulSoup对象 从对象里提取class为’title’的p标签 from urllib.request import urlopen from bs4 import BeautifulSoup for n in range(1,31): url = &apos;www.××××××.com&apos; + str(n) html = urlopen(url) soup = BeautifulSoup(html,&apos;lxml&apos;) titlelist = soup.findAll(&quot;p&quot;,{&quot;class&quot;:&quot;title&quot;}) 现在得到了第一章的所有题目标题的列表。 获取选项和答案选项和答案同样思路 从对象中查找class 为”test-bd f-l”的div标签 chooselist = bs0bj.findAll(“div”,{“class”:”test-bd f-l”}) 使用for循环同时遍历两个列表for title,choose,jiexi in zip(titlelist,chooselist): print(title.get_text()) print(choose.get_text()) 此时将会输出第一章所有的标题、选项和答案 zip:因为要同时遍历两个列表，接受一系列可迭代对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。get_text():把正在处理的HTML文档中的所有标签都清楚，然后返回一个只包含文字的字符串 将得到数据写入文件，并做简单处理将标题、选项、答案写入文件with open(&apos;tiku1.txt&apos;,&apos;w&apos;) as file: *** *** *** for title,choose,jiexi in zip(titlelist,chooselist): file.write(title.get_text()) file.write(choose.get_text()) 文件中包含第一章所有试题，不足之处是多了四个字”查看解析” 使用空值替换多余字符解决办法： 将文件中的数据全部读取出来赋值到字符串a 使用字符串替换，使用空值替换掉“查看解析” 将替换好的字符串写到另一个新文件 # -*- coding:utf-8 -*- with open(&apos;tiku1.txt&apos;,&apos;r&apos;) as f1: a = f1.read() b = a.replace(&apos;查看分析&apos;,&apos;&apos;) with open(&apos;newtiku1.txt&apos;,&apos;w&apos;) as f2: f2.write(b) 题目对应图片的爬取解决图片对应题号问题 ** 思考，并不是每道题都附带图片，但是图片的命名必须要和题号对应起来，所以，在获取选项、答案的基础上再次传到BeautifulSoup对象，然后再次提取img标签，如果某题没有图片，提取的则是一个空值 from urllib.request import urlopen from savepic import saveImg from bs4 import BeautifulSoup i = 1 for n in range(1,30): url = &quot;www.××××××.com&quot;+ str(n) html = urlopen(url) bs0bj = BeautifulSoup(html,&apos;lxml&apos;) chooselist = bs0bj.findAll(&quot;div&quot;,{&quot;class&quot;:&quot;ui-test clearfix titem&quot;}) for choose in chooselist: soup = BeautifulSoup(str(choose),&quot;lxml&quot;) img = soup.find_all([&apos;img&apos;]) if img: for im in img: filename = str(i)+&apos;.png&apos; saveImg(im.get(&apos;src&apos;),filename) print(&quot;保存第{0}题的图片&quot;.format(i)) else: print(&apos;第{0}题没有图片&apos;.format(i)) 图片保存from urllib.request import urlopen def saveImg(imageURL,fileName): u = urlopen(imageURL) data = u.read() with open(&apos;picture/&apos;+fileName, &apos;wb&apos;) as f: f.write(data) 和写入字符串到文件类似，不过这里是以二进制方式写入图片流]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[详细解读14行代码实现字母算术]]></title>
      <url>%2F2017%2F02%2F27%2F%E8%AF%A6%E7%BB%86%E8%A7%A3%E8%AF%BB14%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%AD%97%E6%AF%8D%E7%AE%97%E6%9C%AF%2F</url>
      <content type="text"><![CDATA[HAWAII + IDAHO + IOWA + OHIO == STATES510199 + 98153 + 9301 + 3593 == 621246What is this ？ HAWAII + IDAHO + IOWA + OHIO == STATES510199 + 98153 + 9301 + 3593 == 621246H = 5A = 1W = 0I = 9D = 8O = 3S = 6T = 2E = 4 像这样的谜题被称为cryptarithms 或者 字母算术(alphametics)。字母可以拼出实际的单词，而如果你把每一个字母都用0–9中的某一个数字代替后, 也同样可以拼出 一个算术等式。关键的地方是找出每个字母都映射到了哪个数字。每个字母所有出现的地方都必须映射到同一个数字，数字不能重复, 并且“单词”不能以0开始。 这是&lt;&lt;深入Python3&gt;&gt;上对高级迭代器讲解的例子，仅仅14行代码但有很多知识 使用re.findall()找出出现的所有字符&gt;&gt;&gt; import re &gt;&gt;&gt; puzzle = &apos;HAWAII + IDAHO + IOWA + OHIO == STATES&apos; &gt;&gt;&gt; re.findall(&apos;[A-Z]+&apos;, puzzle.upper()) [&apos;HAWAII&apos;, &apos;IDAHO&apos;, &apos;IOWA&apos;, &apos;OHIO&apos;, &apos;STATES&apos;] 解读： [A-Z] A-Z中的一个字符 匹配指定字符1次或多次 puzzle.upper() 将puzzle字符串所有字符大写 re.findall() findall() 接受一个正则表达式和一个字符串作为参数，然后找出字符串中出现该模式的所有地方 使用join连接元素使用set过滤重复字符&gt;&gt;&gt; words [&apos;HAWAII&apos;, &apos;IDAHO&apos;, &apos;IOWA&apos;, &apos;OHIO&apos;, &apos;STATES&apos;] &gt;&gt;&gt; &apos;&apos;.join(words) &apos;HAWAIIIDAHOIOWAOHIOSTATES&apos; &gt;&gt;&gt; set(&apos;&apos;.join(words)) {&apos;H&apos;, &apos;T&apos;, &apos;S&apos;, &apos;W&apos;, &apos;D&apos;, &apos;I&apos;, &apos;O&apos;, &apos;E&apos;, &apos;A&apos;} 解读 Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。此处以空字符连接words序列 set集合中是无序不重复元素集 通过assert防止出现的字母超过十种&gt;&gt;&gt; unique_characters {&apos;H&apos;, &apos;T&apos;, &apos;S&apos;, &apos;W&apos;, &apos;D&apos;, &apos;I&apos;, &apos;O&apos;, &apos;E&apos;, &apos;A&apos;} &gt;&gt;&gt; len(unique_characters) 9 &gt;&gt;&gt; assert len(unique_characters) &lt;= 10, &apos;Too many letters&apos; &gt;&gt;&gt; assert 1&gt;2, &apos;you are silly&apos; Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; AssertionError: you are silly 解读 len()计算列表、元祖、字符串等序列的长度 assert assert语句用来声明某个条件是真的，、当assert语句失败的时候，会引发异常AssertionError， 可以自己在语句后面添加报错输出信息 通过集合推导获取每个输入字符的首字母并过滤重复&gt;&gt;&gt; words [&apos;HAWAII&apos;, &apos;IDAHO&apos;, &apos;IOWA&apos;, &apos;OHIO&apos;, &apos;STATES&apos;] &gt;&gt;&gt; {word[0] for word in words} {&apos;H&apos;, &apos;S&apos;, &apos;I&apos;, &apos;O&apos;} &gt;&gt;&gt; first_letters = {word[0] for word in words} &gt;&gt;&gt; len(first_letters) 4 解读 此处是集合推导， 获取输入的字符串的第一个字母，并把重复出现的字母过滤掉 对所有出现的字母进行组合(要将每个字符串的首字母放在最前面)&gt;&gt;&gt; &apos;&apos;.join(first_letters) &apos;OHIS&apos; &gt;&gt;&gt; unique_characters - first_letters {&apos;D&apos;, &apos;E&apos;, &apos;A&apos;, &apos;T&apos;, &apos;W&apos;} &gt;&gt;&gt; &apos;&apos;.join(unique_characters - first_letters) &apos;DEATW&apos; &gt;&gt;&gt; &apos;&apos;.join(first_letters) + &apos;&apos;.join(unique_characters - first_letters)&apos;OHISDEATW 解读 此处对所有出现的字母进行组合，因为要求“单词”不能以0开始，所以我们现在把这个开始的字母放在前面，为接下来的排除做准备 获取字母和数字对应的ASCII值&gt;&gt;&gt; ord(&apos;A&apos;) 65 &gt;&gt;&gt; ord(&apos;Z&apos;) 90 &gt;&gt;&gt; tuple(ord(c) for c in sorted_characters) (79, 72, 73, 83, 68, 69, 65, 84, 87) &gt;&gt;&gt; tuple(ord(c) for c in &apos;0123456789&apos;) (48, 49, 50, 51, 52, 53, 54, 55, 56, 57) &gt;&gt;&gt; digits[0] 48 解读 ord()函数: 它以一个字符作为参数，返回对应的ASCII值 (ord(c) for c in sorted_characters) 是一个生成器表达式，最后将生成器表达式传给tuple()，生成器表达式类似一个yield值的匿名函数，返回迭代器。 对出现的所有数字可能的排列进行迭代 &gt;&gt;&gt; import itertools &gt;&gt;&gt; perms = itertools.permutations(&apos;ABC&apos;, 3) &gt;&gt;&gt; list(itertools.permutations(&apos;ABC&apos;, 3)) [(&apos;A&apos;, &apos;B&apos;, &apos;C&apos;), (&apos;A&apos;, &apos;C&apos;, &apos;B&apos;), (&apos;B&apos;, &apos;A&apos;, &apos;C&apos;), (&apos;B&apos;, &apos;C&apos;, &apos;A&apos;), (&apos;C&apos;, &apos;A&apos;, &apos;B&apos;), (&apos;C&apos;, &apos;B&apos;, &apos;A&apos;)] &gt;&gt;&gt; for guess in itertools.permutations(&apos;ABC&apos;, 3): ... print(guess) ... print(guess[:2]) ... (&apos;A&apos;, &apos;B&apos;, &apos;C&apos;) (&apos;A&apos;, &apos;B&apos;) (&apos;A&apos;, &apos;C&apos;, &apos;B&apos;) (&apos;A&apos;, &apos;C&apos;) (&apos;B&apos;, &apos;A&apos;, &apos;C&apos;) (&apos;B&apos;, &apos;A&apos;) (&apos;B&apos;, &apos;C&apos;, &apos;A&apos;) (&apos;B&apos;, &apos;C&apos;) (&apos;C&apos;, &apos;A&apos;, &apos;B&apos;) (&apos;C&apos;, &apos;A&apos;) (&apos;C&apos;, &apos;B&apos;, &apos;A&apos;) (&apos;C&apos;, &apos;B&apos;) 解读 permutations() 函数接受一个序列(这里是3个数字组成的列表) 和一个表示你要的排列的元素的数目的数字。函数返回迭代器，使用for循环对其进行迭代 guess[:2]将guess序列中进行切片操作，前两个元素返回一个新的序列 无数此的转换与匹配检验&gt;&gt;&gt; zip([1,2,3],[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]) &lt;zip object at 0x7fb79d0d3ec8&gt; &gt;&gt;&gt; list(zip(range(0, 3), range(10, 13))) [(0, 10), (1, 11), (2, 12)] &gt;&gt;&gt; dict(zip([1,2,3],[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])) {1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;} &gt;&gt;&gt; translation_table = {ord(&apos;A&apos;): ord(&apos;1&apos;)} &gt;&gt;&gt; translation_table {65: 49} &gt;&gt;&gt; &apos;ABC&apos;.translate(translation_table) &apos;1BC&apos; &gt;&gt;&gt; eval(&apos;1 + 1 == 2&apos;) True &gt;&gt;&gt; eval(&apos;1 + 1 == 3&apos;) False 解读 zip()是Python的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表） dict()对zip函数返回的列表进行字典转换 translate():一个字符串的translate()方法接收一个转换表，并用它来转换该字符串。换句话说，它将出现在转换表的键中的字节替换为该键对应的值.这个例子里， 将ABC “翻译为” 1BC. eval():Python 通用求值工具 源码import re import itertools def solve(puzzle): words = re.findall(&apos;[A-Z]+&apos;, puzzle.upper()) unique_characters = set(&apos;&apos;.join(words)) assert len(unique_characters) &lt;= 10, &apos;Too many letters&apos; first_letters = {word[0] for word in words} n = len(first_letters) sorted_characters = &apos;&apos;.join(first_letters) + \ &apos;&apos;.join(unique_characters - first_letters) characters = tuple(ord(c) for c in sorted_characters) digits = tuple(ord(c) for c in &apos;0123456789&apos;) zero = digits[0] for guess in itertools.permutations(digits, len(characters)): if zero not in guess[:n]: equation = puzzle.translate(dict(zip(characters, guess))) if eval(equation): return equation if __name__ == &apos;__main__&apos;: import sys for puzzle in sys.argv[1:]: print(puzzle) solution = solve(puzzle) if solution: print(solution) try runing : python3 alphametics.py “HAWAII + IDAHO + IOWA + OHIO == STATES” PS: 以后再也不写这样的文档了，别问我为啥、、@ - @]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用github分支多电脑维护hexo]]></title>
      <url>%2F2017%2F02%2F05%2F%E5%88%A9%E7%94%A8github%E5%88%86%E6%94%AF%E5%A4%9A%E7%94%B5%E8%84%91%E7%BB%B4%E6%8A%A4hexo%2F</url>
      <content type="text"><![CDATA[hexo真心很好用，但是如果更换系统或者更换电脑后应该怎么继续维护这个博客呢，我使用了github pages，可以利用github的分支功能解决这个问题，一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。 前提现在已经在一台电脑上搭建好hexo，并且已经部署到github pages，可以成功的发布博客 新建分支提交原始文件初始化在本地博客根目录输入git init，为整个hexo目录初始化git环境 添加远程库将本地与github上的仓库建立关联 git remote add origin git@github.com:MagicRoc/MagicRoc.github.io.git 建立新分支并切换到新分支新建分支hexo并切换到hexo分支 git checkout -b hexo 将hexo生成网站原始的文件提交到hexo分支git add -A git commit -m &quot;原始文件&quot; 将hexo分支推送到远程库git push origin hexo 现在已经成功备份到hexo分支 换系统或者换电脑之后的hexo数据恢复配置环境首先在新环境下安装Node 、Git Node安装升级系统，安装依赖包 sudo apt-get update sudo apt-get install python gcc make g++ 获取源代码，解压 wget http://nodejs.org/dist/v0.12.9/node-v0.12.9.tar.gz tar zxvf node-v0.12.9.tar.gz 编译、安装 cd node-v0.12.4/ ./configure sudo make install Git安装sudo apt-get install git 将本地SSH key添加到github，终端输入： ssh-keygen -t rsa -C &quot;fengyujiancheng@aliyun.com&quot; 然后将用户主目录中的.ssh目录下的id_rsa.pub文件内容复制，登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。 最后不要忘记这两行命令 git config --global user.name &quot;MagicROC&quot; git config --global user.email &quot;fengyujiancheng@aliyun.com&quot; 数据恢复克隆仓库 git clone https://github.com/MagicRoc/MagicRoc.github.io.git 切换到hexo分支 git checkout hexo 安装hexo npm install -g hexo-cli 安装依赖包 npm install 安装git部署插件 npm install hexo-deployer-git 不需要hexo init这条指令 测试 hexo g hexo s 发布博客在hexo分支下写好新博客后执行以下操作 git add . git commit -m &quot;...&quot; git push origin hexo 发布网站到master分支上 hexo g -d]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python图片转字符画]]></title>
      <url>%2F2017%2F02%2F03%2FPython%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB%2F</url>
      <content type="text"><![CDATA[在网上偶然发现一篇使用python实现图片转字符画的文章，觉得很有创意，图片的处理使用PIL。于是尝试了一下，本篇博客主要是参考原文，百度谷歌后解决在实践中遇到的问题，和一些已经解答的疑惑。在此记录所得 分析一张彩色的照片有很多颜色，每种颜色都有对应的RGB值。我们可以这样处理一张图片，将照片深色的部分使用繁琐的字符填充，而浅色的部分使用简单的字符填充，例如” $ “ 和 “ . “两种字符填充可以组成强烈的对比。判断深色部分或者浅色部分使用灰度值 灰度值：指黑白图像中点的颜色深度，范围一般从0到255，白色为255，黑色为0，故黑白图片也称灰度图像 使用灰度值公式将像素的 RGB 值映射到灰度值: gray ＝ 0.2126 * r + 0.7152 * g + 0.0722 * b 这样就可以判断出照片中深色浅色的部位了，因为我们能使用的字符有限，没有办法一个灰度值使用一个字符替代，所以使用一种字符替换三个相近灰度值的部分，我们可以使用”$”字符替代灰度值为0、1、2黑色的部分，用”.”字符替代灰度值为251、252、253的部分，而254、255这样白色的使用空字符 “ “ 安装pillow(PIL)库:$ sudo apt-get update $ sudo apt-get install python-dev $ sudo apt-get install libtiff5-dev libjpeg8-dev zlib1g-dev libfreetype6-dev liblcms2-dev libwebp-dev tcl8.6-dev tk8.6-dev python-tk $ sudo pip install pillow 编写代码导入的库from PIL import Image import argparse parser = argparse.ArgumentParser() parser.add_argument(&apos;file&apos;) #输入文件 parser.add_argument(&apos;-o&apos;, &apos;--output&apos;) #输出文件 parser.add_argument(&apos;--width&apos;, type = int, default = 80) #输出字符画宽 parser.add_argument(&apos;--height&apos;, type = int, default = 80) #输出字符画高 图片的处理使用PIL库中的imageargpase 是解析命令行参数和选择的模块，如需了解，百度谷歌 用于替换图片的字符列表：ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~&lt;&gt;i!lI;:,\&quot;^`&apos;. &quot;) RGB值转换字符的函数def get_char(r,g,b,alpha = 256): if alpha == 0: return &apos; &apos; length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)] 注意几个灰度值共用一个字符 使用Image处理图片im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) image.open(),打开相应的照片，并返回一对象resize()函数处理图片的缩放，WIDTH，HEIGHT则是缩放后的宽高，NEAREST则是缩放的质量，此处是最低质量（ PIL.Image.NEAREST：最低质量， PIL.Image.BILINEAR：双线性，PIL.Image.BICUBIC：三次样条插值，Image.ANTIALIAS：最高质量） 生成表示字符画的字符串for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) txt += &apos;\n&apos; im.getpixel(xy) 返回给定位置的像素值。返回一个含有r,g,b三个值的元组注意元组前面加*号传入Python函数时，元组中的元素被解开作为独立的参数依次传给python函数 完整参考代码 from PIL import Image import argparse parser = argparse.ArgumentParser() #命令行输入参数处理 parser.add_argument(&apos;file&apos;) #输入文件 parser.add_argument(&apos;-o&apos;, &apos;--output&apos;) #输出文件 parser.add_argument(&apos;--width&apos;, type = int, default = 80) #输出字符画宽 parser.add_argument(&apos;--height&apos;, type = int, default = 80) #输出字符画高 args = parser.parse_args() #获取参数 IMG = args.file WIDTH = args.width HEIGHT = args.height OUTPUT = args.output ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~&lt;&gt;i!lI;:,\&quot;^`&apos;. &quot;) def get_char(r,g,b,alpha = 256): # 将256灰度映射到70个字符上 if alpha == 0: return &apos; &apos; length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)] if __name__ == &apos;__main__&apos;: im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) txt = &quot;&quot; for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) txt += &apos;\n&apos; print txt if OUTPUT: #字符画输出到文件 with open(OUTPUT,&apos;w&apos;) as f: f.write(txt) else: with open(&quot;output.txt&quot;,&apos;w&apos;) as f: f.write(txt) 运行程序默认输出文件名output.txt，图片默认高宽80 python image_ascii.py image.jpg 也可以这样制定输出文件名和高宽 python image_ascii.py image.jpg -o put.txt --width 40 --height 40 效果图自己的照片对应的字符画 网上找的卡通照片原图以及对应的字符画]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flask-admin使用经验技巧总结]]></title>
      <url>%2F2017%2F01%2F22%2FFlask-admin%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[前段时间自学了Flask框架，看得狗书入门，最近做一个新闻发布网站准备拿Flask来做，尝试一下Flask快速开发，并且练练手，于是接触到了Flask-admin。总结一下Flask-admin 首先需要导入的包from flask_admin import Admin,BaseView,expose,AdminIndexView from flask_admin.contrib.sqla import ModelView 效果图 模型视图 管理新闻、管理公告、管理文件、管理展示栏是四个与数据库表同步的模型视图，如果你想要在后台管理程序中数据库中的表在初始化admin后仅需一句代码 admin = Admin(app) admin.add_view(ModelView(User, db.session))&apos; 但是有时候flask-admin的默认设置并不能满足你的条件，如果我们在后台只打算让表中固定的几列数据显示,这时候我们就不能直接像上面那样直接ModelView，我们需自定义一个类并继承ModelView，并重写一些代码，把想要显示出来的列名写在column_list中 class MyV1(ModelView): column_list = (&apos;id&apos;, &apos;title&apos;,&apos;timestamp&apos;,&apos;count&apos;,&apos;content&apos;) def __init__(self, session, **kwargs): super(MyV1, self).__init__(News, session, **kwargs) 然后在程序中再加入代码如下，然后就OK了 admin.add_view(MyV1(db.session,name = u&apos;管理新闻&apos;)) 如果我们使用flask做网站是给自己使用，后台和数据库中同步的列名是英文显示没有多大影响，自己写的数据库难道还不知道什么意思，但是当我们是写给非技术人员使用时，他们可能不能理解每个列名是什么意思，所以现在我们就需要将列名中文化，也是需要重写column_labels class MyV1(ModelView): column_labels = { &apos;id&apos;:u&apos;序号&apos;, &apos;title&apos; : u&apos;新闻标题&apos;, &apos;timestamp&apos;:u&apos;发布时间&apos;, &apos;count&apos;:u&apos;浏览次数&apos;, &apos;content&apos;:u&apos;新闻内容&apos; } column_list = (&apos;id&apos;, &apos;title&apos;,&apos;timestamp&apos;,&apos;count&apos;,&apos;content&apos;) def __init__(self, session, **kwargs): super(MyV1, self).__init__(News, session, **kwargs) 有时候当同步数据库表成功后，扩展会有一个默认新建数据插入数据库表中的功能，但是我们有时候发表博客、新闻这些需要排版的文章但是默认的新建数据不支持这个功能怎么办，我们可以把默认创建功能先关掉。 class MyV1(ModelView): can_create = False column_labels = { &apos;id&apos;:u&apos;序号&apos;, &apos;title&apos; : u&apos;新闻标题&apos;, &apos;timestamp&apos;:u&apos;发布时间&apos;, &apos;count&apos;:u&apos;浏览次数&apos;, &apos;content&apos;:u&apos;新闻内容&apos; } column_list = (&apos;id&apos;, &apos;title&apos;,&apos;timestamp&apos;,&apos;count&apos;,&apos;content&apos;) def __init__(self, session, **kwargs): super(MyV1, self).__init__(News, session, **kwargs) 创建视图 上面我们说到讲默认创建功能关掉，但是我们怎么新建数据呢，我们可以自己写一个视图，关联自己的模板，再在模板中集成富文本。 class MyNews(BaseView): @expose(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]) def index(self): form = NameForm() return self.render(&apos;donews.html&apos;, form=form) 然后再程序中加入代码 admin.add_view(MyNews(name=u&apos;发表新闻&apos;)) 对主页面的修改 Flask-admin默认主页面标题是Home，而且界面一片空白，由于各种需要，我们需要对这些进行更改，参考以下代码复制代码 admin = Admin( app, index_view=AdminIndexView( name=&apos;导航栏&apos;, template=&apos;welcome.html&apos;, url=&apos;/admin&apos; ) ) 将标题修改为导航栏，并将主页设置为welcome.html，进入后台对应的url也可以修改 权限设置 一般后台并不是对所有用户开放的，所有牵扯到了管理员权限，这一块我是依靠flask-login这个扩展实现的，关于flask-login会再写一遍进行总结，新加代码如下 class MyNews(BaseView): def is_accessible(self): if current_user.is_authenticated and current_user.username == &quot;admin&quot;: return True return False @expose(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]) def index(self): form = NameForm() return self.render(&apos;donews.html&apos;, form=form) 通过判断当前用户登录状态和当前登录的用户名进行权限设置]]></content>
    </entry>

    
  
  
</search>
