<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[利用github分支多电脑维护hexo]]></title>
      <url>%2F2017%2F02%2F05%2F%E5%88%A9%E7%94%A8github%E5%88%86%E6%94%AF%E5%A4%9A%E7%94%B5%E8%84%91%E7%BB%B4%E6%8A%A4hexo%2F</url>
      <content type="text"><![CDATA[hexo真心很好用，但是如果更换系统或者更换电脑后应该怎么继续维护这个博客呢，我使用了github pages，可以利用github的分支功能解决这个问题，一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。 前提现在已经在一台电脑上搭建好hexo，并且已经部署到github pages，可以成功的发布博客 新建分支提交原始文件初始化在本地博客根目录输入git init，为整个hexo目录初始化git环境 添加远程库将本地与github上的仓库建立关联 git remote add origin git@github.com:MagicRoc/MagicRoc.github.io.git 建立新分支并切换到新分支新建分支hexo并切换到hexo分支 git checkout -b hexo 将hexo生成网站原始的文件提交到hexo分支git add -A git commit -m &quot;原始文件&quot; 将hexo分支推送到远程库git push origin hexo 现在已经成功备份到hexo分支 换系统或者换电脑之后的hexo数据恢复配置环境首先在新环境下安装Node 、Git Node安装升级系统，安装依赖包 sudo apt-get update sudo apt-get install python gcc make g++ 获取源代码，解压 wget http://nodejs.org/dist/v0.12.9/node-v0.12.9.tar.gz tar zxvf node-v0.12.9.tar.gz 编译、安装 cd node-v0.12.4/ ./configure sudo make install Git安装sudo apt-get install git 将本地SSH key添加到github，终端输入： ssh-keygen -t rsa -C &quot;fengyujiancheng@aliyun.com&quot; 然后将用户主目录中的.ssh目录下的id_rsa.pub文件内容复制，登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。 最后不要忘记这两行命令 git config --global user.name &quot;MagicROC&quot; git config --global user.email &quot;fengyujiancheng@aliyun.com&quot; 数据恢复克隆仓库 git clone https://github.com/MagicRoc/MagicRoc.github.io.git 切换到hexo分支 git checkout hexo 安装hexo npm install -g hexo-cli 安装依赖包 npm install 安装git部署插件 npm install hexo-deployer-git 不需要hexo init这条指令 测试 hexo g hexo s 发布博客在hexo分支下写好新博客后执行以下操作 git add . git commit -m &quot;...&quot; git push origin hexo 发布网站到master分支上 hexo g -d]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python图片转字符画]]></title>
      <url>%2F2017%2F02%2F03%2FPython%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB%2F</url>
      <content type="text"><![CDATA[在网上偶然发现一篇使用python实现图片转字符画的文章，觉得很有创意，图片的处理使用PIL。于是尝试了一下，本篇博客主要是参考原文，百度谷歌后解决在实践中遇到的问题，和一些已经解答的疑惑。在此记录所得 分析一张彩色的照片有很多颜色，每种颜色都有对应的RGB值。我们可以这样处理一张图片，将照片深色的部分使用繁琐的字符填充，而浅色的部分使用简单的字符填充，例如” $ “ 和 “ . “两种字符填充可以组成强烈的对比。判断深色部分或者浅色部分使用灰度值 灰度值：指黑白图像中点的颜色深度，范围一般从0到255，白色为255，黑色为0，故黑白图片也称灰度图像 使用灰度值公式将像素的 RGB 值映射到灰度值: gray ＝ 0.2126 * r + 0.7152 * g + 0.0722 * b 这样就可以判断出照片中深色浅色的部位了，因为我们能使用的字符有限，没有办法一个灰度值使用一个字符替代，所以使用一种字符替换三个相近灰度值的部分，我们可以使用”$”字符替代灰度值为0、1、2黑色的部分，用”.”字符替代灰度值为251、252、253的部分，而254、255这样白色的使用空字符 “ “ 安装pillow(PIL)库:$ sudo apt-get update $ sudo apt-get install python-dev $ sudo apt-get install libtiff5-dev libjpeg8-dev zlib1g-dev libfreetype6-dev liblcms2-dev libwebp-dev tcl8.6-dev tk8.6-dev python-tk $ sudo pip install pillow 编写代码导入的库from PIL import Image import argparse parser = argparse.ArgumentParser() parser.add_argument(&apos;file&apos;) #输入文件 parser.add_argument(&apos;-o&apos;, &apos;--output&apos;) #输出文件 parser.add_argument(&apos;--width&apos;, type = int, default = 80) #输出字符画宽 parser.add_argument(&apos;--height&apos;, type = int, default = 80) #输出字符画高 图片的处理使用PIL库中的imageargpase 是解析命令行参数和选择的模块，如需了解，百度谷歌 用于替换图片的字符列表：ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~&lt;&gt;i!lI;:,\&quot;^`&apos;. &quot;) RGB值转换字符的函数def get_char(r,g,b,alpha = 256): if alpha == 0: return &apos; &apos; length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)] 注意几个灰度值共用一个字符 使用Image处理图片im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) image.open(),打开相应的照片，并返回一对象resize()函数处理图片的缩放，WIDTH，HEIGHT则是缩放后的宽高，NEAREST则是缩放的质量，此处是最低质量（ PIL.Image.NEAREST：最低质量， PIL.Image.BILINEAR：双线性，PIL.Image.BICUBIC：三次样条插值，Image.ANTIALIAS：最高质量） 生成表示字符画的字符串for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) txt += &apos;\n&apos; im.getpixel(xy) 返回给定位置的像素值。返回一个含有r,g,b三个值的元组注意元组前面加*号传入Python函数时，元组中的元素被解开作为独立的参数依次传给python函数 完整参考代码 from PIL import Image import argparse parser = argparse.ArgumentParser() #命令行输入参数处理 parser.add_argument(&apos;file&apos;) #输入文件 parser.add_argument(&apos;-o&apos;, &apos;--output&apos;) #输出文件 parser.add_argument(&apos;--width&apos;, type = int, default = 80) #输出字符画宽 parser.add_argument(&apos;--height&apos;, type = int, default = 80) #输出字符画高 args = parser.parse_args() #获取参数 IMG = args.file WIDTH = args.width HEIGHT = args.height OUTPUT = args.output ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~&lt;&gt;i!lI;:,\&quot;^`&apos;. &quot;) def get_char(r,g,b,alpha = 256): # 将256灰度映射到70个字符上 if alpha == 0: return &apos; &apos; length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)] if __name__ == &apos;__main__&apos;: im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) txt = &quot;&quot; for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) txt += &apos;\n&apos; print txt if OUTPUT: #字符画输出到文件 with open(OUTPUT,&apos;w&apos;) as f: f.write(txt) else: with open(&quot;output.txt&quot;,&apos;w&apos;) as f: f.write(txt) 运行程序默认输出文件名output.txt，图片默认高宽80 python image_ascii.py image.jpg 也可以这样制定输出文件名和高宽 python image_ascii.py image.jpg -o put.txt --width 40 --height 40 效果图自己的照片对应的字符画 网上找的卡通照片原图以及对应的字符画]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flask-admin使用经验技巧总结]]></title>
      <url>%2F2017%2F01%2F22%2FFlask-admin%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[前段时间自学了Flask框架，看得狗书入门，最近做一个新闻发布网站准备拿Flask来做，尝试一下Flask快速开发，并且练练手，于是接触到了Flask-admin。总结一下Flask-admin 首先需要导入的包from flask_admin import Admin,BaseView,expose,AdminIndexView from flask_admin.contrib.sqla import ModelView 效果图 模型视图 管理新闻、管理公告、管理文件、管理展示栏是四个与数据库表同步的模型视图，如果你想要在后台管理程序中数据库中的表在初始化admin后仅需一句代码 admin = Admin(app) admin.add_view(ModelView(User, db.session))&apos; 但是有时候flask-admin的默认设置并不能满足你的条件，如果我们在后台只打算让表中固定的几列数据显示,这时候我们就不能直接像上面那样直接ModelView，我们需自定义一个类并继承ModelView，并重写一些代码，把想要显示出来的列名写在column_list中 class MyV1(ModelView): column_list = (&apos;id&apos;, &apos;title&apos;,&apos;timestamp&apos;,&apos;count&apos;,&apos;content&apos;) def __init__(self, session, **kwargs): super(MyV1, self).__init__(News, session, **kwargs) 然后在程序中再加入代码如下，然后就OK了 admin.add_view(MyV1(db.session,name = u&apos;管理新闻&apos;)) 如果我们使用flask做网站是给自己使用，后台和数据库中同步的列名是英文显示没有多大影响，自己写的数据库难道还不知道什么意思，但是当我们是写给非技术人员使用时，他们可能不能理解每个列名是什么意思，所以现在我们就需要将列名中文化，也是需要重写column_labels class MyV1(ModelView): column_labels = { &apos;id&apos;:u&apos;序号&apos;, &apos;title&apos; : u&apos;新闻标题&apos;, &apos;timestamp&apos;:u&apos;发布时间&apos;, &apos;count&apos;:u&apos;浏览次数&apos;, &apos;content&apos;:u&apos;新闻内容&apos; } column_list = (&apos;id&apos;, &apos;title&apos;,&apos;timestamp&apos;,&apos;count&apos;,&apos;content&apos;) def __init__(self, session, **kwargs): super(MyV1, self).__init__(News, session, **kwargs) 有时候当同步数据库表成功后，扩展会有一个默认新建数据插入数据库表中的功能，但是我们有时候发表博客、新闻这些需要排版的文章但是默认的新建数据不支持这个功能怎么办，我们可以把默认创建功能先关掉。 class MyV1(ModelView): can_create = False column_labels = { &apos;id&apos;:u&apos;序号&apos;, &apos;title&apos; : u&apos;新闻标题&apos;, &apos;timestamp&apos;:u&apos;发布时间&apos;, &apos;count&apos;:u&apos;浏览次数&apos;, &apos;content&apos;:u&apos;新闻内容&apos; } column_list = (&apos;id&apos;, &apos;title&apos;,&apos;timestamp&apos;,&apos;count&apos;,&apos;content&apos;) def __init__(self, session, **kwargs): super(MyV1, self).__init__(News, session, **kwargs) 创建视图 上面我们说到讲默认创建功能关掉，但是我们怎么新建数据呢，我们可以自己写一个视图，关联自己的模板，再在模板中集成富文本。 class MyNews(BaseView): @expose(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]) def index(self): form = NameForm() return self.render(&apos;donews.html&apos;, form=form) 然后再程序中加入代码 admin.add_view(MyNews(name=u&apos;发表新闻&apos;)) 对主页面的修改 Flask-admin默认主页面标题是Home，而且界面一片空白，由于各种需要，我们需要对这些进行更改，参考以下代码复制代码 admin = Admin( app, index_view=AdminIndexView( name=&apos;导航栏&apos;, template=&apos;welcome.html&apos;, url=&apos;/admin&apos; ) ) 将标题修改为导航栏，并将主页设置为welcome.html，进入后台对应的url也可以修改 权限设置 一般后台并不是对所有用户开放的，所有牵扯到了管理员权限，这一块我是依靠flask-login这个扩展实现的，关于flask-login会再写一遍进行总结，新加代码如下 class MyNews(BaseView): def is_accessible(self): if current_user.is_authenticated and current_user.username == &quot;admin&quot;: return True return False @expose(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]) def index(self): form = NameForm() return self.render(&apos;donews.html&apos;, form=form) 通过判断当前用户登录状态和当前登录的用户名进行权限设置]]></content>
    </entry>

    
  
  
</search>
