<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python爬虫初探（一）]]></title>
      <url>%2F2017%2F03%2F12%2FPython%E7%88%AC%E8%99%AB%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[最近参与了的一个项目，因为项目需要驾照考试科一和科四的完整题库，网上找了好久找不到完整版题库，所以才有了这篇博客的由来，因为技术不太好，之前学习的又是Python web相关的知识，所以关于程序的代码可能有些繁琐、低效。见谅 分析得到标题、选项和答案首先看一下要爬取的网页源码内容，科目一共有四章，第一章有30页，每页二十道题，这是第一章第一页的第一题 &lt;a href=&quot;/tiba/9294/&quot; target=&quot;_blank&quot;&gt; &lt;div class=&quot;ui-test clearfix titem&quot;&gt; &lt;p class=&quot;title&quot;&gt;1、&amp;nbsp;如图所示，A车在此处停车是可以的。&lt;/p&gt; &lt;!--判断--&gt; &lt;div class=&quot;test-bd f-l&quot;&gt; &lt;ul&gt; &lt;li&gt;A、正确&lt;/li&gt; &lt;li&gt;B、错误&lt;/li&gt; &lt;li class=&quot;answer&quot;&gt;&lt;strong class=&quot;right&quot;&gt;答案：&lt;/strong&gt; &lt;strong&gt;对&lt;/strong&gt;&lt;span style=&quot;margin-left:100px;display:inline-block;&quot;&gt;查看分析&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;test-r f-r&quot;&gt; &lt;img src=&quot;http://www.jiazhao.com/images/tiku/1436112505.png&quot; &gt;&lt;!-- &lt;a href=&quot;javascript:;&quot; class=&quot;t-big&quot;&gt;查看大图&lt;/a&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/a&gt; 获取标题思考 利用urllib.request.urlopen获取网页HTML内容 将HTML内容传到BeautifulSoup对象 从对象里提取class为’title’的p标签 from urllib.request import urlopen from bs4 import BeautifulSoup for n in range(1,31): url = &apos;www.××××××.com&apos; + str(n) html = urlopen(url) soup = BeautifulSoup(html,&apos;lxml&apos;) titlelist = soup.findAll(&quot;p&quot;,{&quot;class&quot;:&quot;title&quot;}) 现在得到了第一章的所有题目标题的列表。 获取选项和答案选项和答案同样思路 从对象中查找class 为”test-bd f-l”的div标签 chooselist = bs0bj.findAll(“div”,{“class”:”test-bd f-l”}) 使用for循环同时遍历两个列表for title,choose,jiexi in zip(titlelist,chooselist): print(title.get_text()) print(choose.get_text()) 此时将会输出第一章所有的标题、选项和答案 zip:因为要同时遍历两个列表，接受一系列可迭代对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。get_text():把正在处理的HTML文档中的所有标签都清楚，然后返回一个只包含文字的字符串 将得到数据写入文件，并做简单处理将标题、选项、答案写入文件with open(&apos;tiku1.txt&apos;,&apos;w&apos;) as file: *** *** *** for title,choose,jiexi in zip(titlelist,chooselist): file.write(title.get_text()) file.write(choose.get_text()) 文件中包含第一章所有试题，不足之处是多了四个字”查看解析” 使用空值替换多余字符解决办法： 将文件中的数据全部读取出来赋值到字符串a 使用字符串替换，使用空值替换掉“查看解析” 将替换好的字符串写到另一个新文件 # -*- coding:utf-8 -*- with open(&apos;tiku1.txt&apos;,&apos;r&apos;) as f1: a = f1.read() b = a.replace(&apos;查看分析&apos;,&apos;&apos;) with open(&apos;newtiku1.txt&apos;,&apos;w&apos;) as f2: f2.write(b) 题目对应图片的爬取解决图片对应题号问题 ** 思考，并不是每道题都附带图片，但是图片的命名必须要和题号对应起来，所以，在获取选项、答案的基础上再次传到BeautifulSoup对象，然后再次提取img标签，如果某题没有图片，提取的则是一个空值 from urllib.request import urlopen from savepic import saveImg from bs4 import BeautifulSoup i = 1 for n in range(1,30): url = &quot;www.××××××.com&quot;+ str(n) html = urlopen(url) bs0bj = BeautifulSoup(html,&apos;lxml&apos;) chooselist = bs0bj.findAll(&quot;div&quot;,{&quot;class&quot;:&quot;ui-test clearfix titem&quot;}) for choose in chooselist: soup = BeautifulSoup(str(choose),&quot;lxml&quot;) img = soup.find_all([&apos;img&apos;]) if img: for im in img: filename = str(i)+&apos;.png&apos; saveImg(im.get(&apos;src&apos;),filename) print(&quot;保存第{0}题的图片&quot;.format(i)) else: print(&apos;第{0}题没有图片&apos;.format(i)) 图片保存from urllib.request import urlopen def saveImg(imageURL,fileName): u = urlopen(imageURL) data = u.read() with open(&apos;picture/&apos;+fileName, &apos;wb&apos;) as f: f.write(data) 和写入字符串到文件类似，不过这里是以二进制方式写入图片流]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[详细解读14行代码实现字母算术]]></title>
      <url>%2F2017%2F02%2F27%2F%E8%AF%A6%E7%BB%86%E8%A7%A3%E8%AF%BB14%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%AD%97%E6%AF%8D%E7%AE%97%E6%9C%AF%2F</url>
      <content type="text"><![CDATA[HAWAII + IDAHO + IOWA + OHIO == STATES510199 + 98153 + 9301 + 3593 == 621246What is this ？ HAWAII + IDAHO + IOWA + OHIO == STATES510199 + 98153 + 9301 + 3593 == 621246H = 5A = 1W = 0I = 9D = 8O = 3S = 6T = 2E = 4 像这样的谜题被称为cryptarithms 或者 字母算术(alphametics)。字母可以拼出实际的单词，而如果你把每一个字母都用0–9中的某一个数字代替后, 也同样可以拼出 一个算术等式。关键的地方是找出每个字母都映射到了哪个数字。每个字母所有出现的地方都必须映射到同一个数字，数字不能重复, 并且“单词”不能以0开始。 这是&lt;&lt;深入Python3&gt;&gt;上对高级迭代器讲解的例子，仅仅14行代码但有很多知识 使用re.findall()找出出现的所有字符&gt;&gt;&gt; import re &gt;&gt;&gt; puzzle = &apos;HAWAII + IDAHO + IOWA + OHIO == STATES&apos; &gt;&gt;&gt; re.findall(&apos;[A-Z]+&apos;, puzzle.upper()) [&apos;HAWAII&apos;, &apos;IDAHO&apos;, &apos;IOWA&apos;, &apos;OHIO&apos;, &apos;STATES&apos;] 解读： [A-Z] A-Z中的一个字符 匹配指定字符1次或多次 puzzle.upper() 将puzzle字符串所有字符大写 re.findall() findall() 接受一个正则表达式和一个字符串作为参数，然后找出字符串中出现该模式的所有地方 使用join连接元素使用set过滤重复字符&gt;&gt;&gt; words [&apos;HAWAII&apos;, &apos;IDAHO&apos;, &apos;IOWA&apos;, &apos;OHIO&apos;, &apos;STATES&apos;] &gt;&gt;&gt; &apos;&apos;.join(words) &apos;HAWAIIIDAHOIOWAOHIOSTATES&apos; &gt;&gt;&gt; set(&apos;&apos;.join(words)) {&apos;H&apos;, &apos;T&apos;, &apos;S&apos;, &apos;W&apos;, &apos;D&apos;, &apos;I&apos;, &apos;O&apos;, &apos;E&apos;, &apos;A&apos;} 解读 Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。此处以空字符连接words序列 set集合中是无序不重复元素集 通过assert防止出现的字母超过十种&gt;&gt;&gt; unique_characters {&apos;H&apos;, &apos;T&apos;, &apos;S&apos;, &apos;W&apos;, &apos;D&apos;, &apos;I&apos;, &apos;O&apos;, &apos;E&apos;, &apos;A&apos;} &gt;&gt;&gt; len(unique_characters) 9 &gt;&gt;&gt; assert len(unique_characters) &lt;= 10, &apos;Too many letters&apos; &gt;&gt;&gt; assert 1&gt;2, &apos;you are silly&apos; Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; AssertionError: you are silly 解读 len()计算列表、元祖、字符串等序列的长度 assert assert语句用来声明某个条件是真的，、当assert语句失败的时候，会引发异常AssertionError， 可以自己在语句后面添加报错输出信息 通过集合推导获取每个输入字符的首字母并过滤重复&gt;&gt;&gt; words [&apos;HAWAII&apos;, &apos;IDAHO&apos;, &apos;IOWA&apos;, &apos;OHIO&apos;, &apos;STATES&apos;] &gt;&gt;&gt; {word[0] for word in words} {&apos;H&apos;, &apos;S&apos;, &apos;I&apos;, &apos;O&apos;} &gt;&gt;&gt; first_letters = {word[0] for word in words} &gt;&gt;&gt; len(first_letters) 4 解读 此处是集合推导， 获取输入的字符串的第一个字母，并把重复出现的字母过滤掉 对所有出现的字母进行组合(要将每个字符串的首字母放在最前面)&gt;&gt;&gt; &apos;&apos;.join(first_letters) &apos;OHIS&apos; &gt;&gt;&gt; unique_characters - first_letters {&apos;D&apos;, &apos;E&apos;, &apos;A&apos;, &apos;T&apos;, &apos;W&apos;} &gt;&gt;&gt; &apos;&apos;.join(unique_characters - first_letters) &apos;DEATW&apos; &gt;&gt;&gt; &apos;&apos;.join(first_letters) + &apos;&apos;.join(unique_characters - first_letters)&apos;OHISDEATW 解读 此处对所有出现的字母进行组合，因为要求“单词”不能以0开始，所以我们现在把这个开始的字母放在前面，为接下来的排除做准备 获取字母和数字对应的ASCII值&gt;&gt;&gt; ord(&apos;A&apos;) 65 &gt;&gt;&gt; ord(&apos;Z&apos;) 90 &gt;&gt;&gt; tuple(ord(c) for c in sorted_characters) (79, 72, 73, 83, 68, 69, 65, 84, 87) &gt;&gt;&gt; tuple(ord(c) for c in &apos;0123456789&apos;) (48, 49, 50, 51, 52, 53, 54, 55, 56, 57) &gt;&gt;&gt; digits[0] 48 解读 ord()函数: 它以一个字符作为参数，返回对应的ASCII值 (ord(c) for c in sorted_characters) 是一个生成器表达式，最后将生成器表达式传给tuple()，生成器表达式类似一个yield值的匿名函数，返回迭代器。 对出现的所有数字可能的排列进行迭代 &gt;&gt;&gt; import itertools &gt;&gt;&gt; perms = itertools.permutations(&apos;ABC&apos;, 3) &gt;&gt;&gt; list(itertools.permutations(&apos;ABC&apos;, 3)) [(&apos;A&apos;, &apos;B&apos;, &apos;C&apos;), (&apos;A&apos;, &apos;C&apos;, &apos;B&apos;), (&apos;B&apos;, &apos;A&apos;, &apos;C&apos;), (&apos;B&apos;, &apos;C&apos;, &apos;A&apos;), (&apos;C&apos;, &apos;A&apos;, &apos;B&apos;), (&apos;C&apos;, &apos;B&apos;, &apos;A&apos;)] &gt;&gt;&gt; for guess in itertools.permutations(&apos;ABC&apos;, 3): ... print(guess) ... print(guess[:2]) ... (&apos;A&apos;, &apos;B&apos;, &apos;C&apos;) (&apos;A&apos;, &apos;B&apos;) (&apos;A&apos;, &apos;C&apos;, &apos;B&apos;) (&apos;A&apos;, &apos;C&apos;) (&apos;B&apos;, &apos;A&apos;, &apos;C&apos;) (&apos;B&apos;, &apos;A&apos;) (&apos;B&apos;, &apos;C&apos;, &apos;A&apos;) (&apos;B&apos;, &apos;C&apos;) (&apos;C&apos;, &apos;A&apos;, &apos;B&apos;) (&apos;C&apos;, &apos;A&apos;) (&apos;C&apos;, &apos;B&apos;, &apos;A&apos;) (&apos;C&apos;, &apos;B&apos;) 解读 permutations() 函数接受一个序列(这里是3个数字组成的列表) 和一个表示你要的排列的元素的数目的数字。函数返回迭代器，使用for循环对其进行迭代 guess[:2]将guess序列中进行切片操作，前两个元素返回一个新的序列 无数此的转换与匹配检验&gt;&gt;&gt; zip([1,2,3],[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]) &lt;zip object at 0x7fb79d0d3ec8&gt; &gt;&gt;&gt; list(zip(range(0, 3), range(10, 13))) [(0, 10), (1, 11), (2, 12)] &gt;&gt;&gt; dict(zip([1,2,3],[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])) {1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;} &gt;&gt;&gt; translation_table = {ord(&apos;A&apos;): ord(&apos;1&apos;)} &gt;&gt;&gt; translation_table {65: 49} &gt;&gt;&gt; &apos;ABC&apos;.translate(translation_table) &apos;1BC&apos; &gt;&gt;&gt; eval(&apos;1 + 1 == 2&apos;) True &gt;&gt;&gt; eval(&apos;1 + 1 == 3&apos;) False 解读 zip()是Python的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表） dict()对zip函数返回的列表进行字典转换 translate():一个字符串的translate()方法接收一个转换表，并用它来转换该字符串。换句话说，它将出现在转换表的键中的字节替换为该键对应的值.这个例子里， 将ABC “翻译为” 1BC. eval():Python 通用求值工具 源码import re import itertools def solve(puzzle): words = re.findall(&apos;[A-Z]+&apos;, puzzle.upper()) unique_characters = set(&apos;&apos;.join(words)) assert len(unique_characters) &lt;= 10, &apos;Too many letters&apos; first_letters = {word[0] for word in words} n = len(first_letters) sorted_characters = &apos;&apos;.join(first_letters) + \ &apos;&apos;.join(unique_characters - first_letters) characters = tuple(ord(c) for c in sorted_characters) digits = tuple(ord(c) for c in &apos;0123456789&apos;) zero = digits[0] for guess in itertools.permutations(digits, len(characters)): if zero not in guess[:n]: equation = puzzle.translate(dict(zip(characters, guess))) if eval(equation): return equation if __name__ == &apos;__main__&apos;: import sys for puzzle in sys.argv[1:]: print(puzzle) solution = solve(puzzle) if solution: print(solution) try runing : python3 alphametics.py “HAWAII + IDAHO + IOWA + OHIO == STATES” PS: 以后再也不写这样的文档了，别问我为啥、、@ - @]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用github分支多电脑维护hexo]]></title>
      <url>%2F2017%2F02%2F05%2F%E5%88%A9%E7%94%A8github%E5%88%86%E6%94%AF%E5%A4%9A%E7%94%B5%E8%84%91%E7%BB%B4%E6%8A%A4hexo%2F</url>
      <content type="text"><![CDATA[hexo真心很好用，但是如果更换系统或者更换电脑后应该怎么继续维护这个博客呢，我使用了github pages，可以利用github的分支功能解决这个问题，一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。 前提现在已经在一台电脑上搭建好hexo，并且已经部署到github pages，可以成功的发布博客 新建分支提交原始文件初始化在本地博客根目录输入git init，为整个hexo目录初始化git环境 添加远程库将本地与github上的仓库建立关联 git remote add origin git@github.com:MagicRoc/MagicRoc.github.io.git 建立新分支并切换到新分支新建分支hexo并切换到hexo分支 git checkout -b hexo 将hexo生成网站原始的文件提交到hexo分支git add -A git commit -m &quot;原始文件&quot; 将hexo分支推送到远程库git push origin hexo 现在已经成功备份到hexo分支 换系统或者换电脑之后的hexo数据恢复配置环境首先在新环境下安装Node 、Git Node安装升级系统，安装依赖包 sudo apt-get update sudo apt-get install python gcc make g++ 获取源代码，解压 wget http://nodejs.org/dist/v0.12.9/node-v0.12.9.tar.gz tar zxvf node-v0.12.9.tar.gz 编译、安装 cd node-v0.12.4/ ./configure sudo make install Git安装sudo apt-get install git 将本地SSH key添加到github，终端输入： ssh-keygen -t rsa -C &quot;fengyujiancheng@aliyun.com&quot; 然后将用户主目录中的.ssh目录下的id_rsa.pub文件内容复制，登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。 最后不要忘记这两行命令 git config --global user.name &quot;MagicROC&quot; git config --global user.email &quot;fengyujiancheng@aliyun.com&quot; 数据恢复克隆仓库 git clone https://github.com/MagicRoc/MagicRoc.github.io.git 切换到hexo分支 git checkout hexo 安装hexo npm install -g hexo-cli 安装依赖包 npm install 安装git部署插件 npm install hexo-deployer-git 不需要hexo init这条指令 测试 hexo g hexo s 发布博客在hexo分支下写好新博客后执行以下操作 git add . git commit -m &quot;...&quot; git push origin hexo 发布网站到master分支上 hexo g -d]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python图片转字符画]]></title>
      <url>%2F2017%2F02%2F03%2FPython%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB%2F</url>
      <content type="text"><![CDATA[在网上偶然发现一篇使用python实现图片转字符画的文章，觉得很有创意，图片的处理使用PIL。于是尝试了一下，本篇博客主要是参考原文，百度谷歌后解决在实践中遇到的问题，和一些已经解答的疑惑。在此记录所得 分析一张彩色的照片有很多颜色，每种颜色都有对应的RGB值。我们可以这样处理一张图片，将照片深色的部分使用繁琐的字符填充，而浅色的部分使用简单的字符填充，例如” $ “ 和 “ . “两种字符填充可以组成强烈的对比。判断深色部分或者浅色部分使用灰度值 灰度值：指黑白图像中点的颜色深度，范围一般从0到255，白色为255，黑色为0，故黑白图片也称灰度图像 使用灰度值公式将像素的 RGB 值映射到灰度值: gray ＝ 0.2126 * r + 0.7152 * g + 0.0722 * b 这样就可以判断出照片中深色浅色的部位了，因为我们能使用的字符有限，没有办法一个灰度值使用一个字符替代，所以使用一种字符替换三个相近灰度值的部分，我们可以使用”$”字符替代灰度值为0、1、2黑色的部分，用”.”字符替代灰度值为251、252、253的部分，而254、255这样白色的使用空字符 “ “ 安装pillow(PIL)库:$ sudo apt-get update $ sudo apt-get install python-dev $ sudo apt-get install libtiff5-dev libjpeg8-dev zlib1g-dev libfreetype6-dev liblcms2-dev libwebp-dev tcl8.6-dev tk8.6-dev python-tk $ sudo pip install pillow 编写代码导入的库from PIL import Image import argparse parser = argparse.ArgumentParser() parser.add_argument(&apos;file&apos;) #输入文件 parser.add_argument(&apos;-o&apos;, &apos;--output&apos;) #输出文件 parser.add_argument(&apos;--width&apos;, type = int, default = 80) #输出字符画宽 parser.add_argument(&apos;--height&apos;, type = int, default = 80) #输出字符画高 图片的处理使用PIL库中的imageargpase 是解析命令行参数和选择的模块，如需了解，百度谷歌 用于替换图片的字符列表：ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~&lt;&gt;i!lI;:,\&quot;^`&apos;. &quot;) RGB值转换字符的函数def get_char(r,g,b,alpha = 256): if alpha == 0: return &apos; &apos; length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)] 注意几个灰度值共用一个字符 使用Image处理图片im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) image.open(),打开相应的照片，并返回一对象resize()函数处理图片的缩放，WIDTH，HEIGHT则是缩放后的宽高，NEAREST则是缩放的质量，此处是最低质量（ PIL.Image.NEAREST：最低质量， PIL.Image.BILINEAR：双线性，PIL.Image.BICUBIC：三次样条插值，Image.ANTIALIAS：最高质量） 生成表示字符画的字符串for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) txt += &apos;\n&apos; im.getpixel(xy) 返回给定位置的像素值。返回一个含有r,g,b三个值的元组注意元组前面加*号传入Python函数时，元组中的元素被解开作为独立的参数依次传给python函数 完整参考代码 from PIL import Image import argparse parser = argparse.ArgumentParser() #命令行输入参数处理 parser.add_argument(&apos;file&apos;) #输入文件 parser.add_argument(&apos;-o&apos;, &apos;--output&apos;) #输出文件 parser.add_argument(&apos;--width&apos;, type = int, default = 80) #输出字符画宽 parser.add_argument(&apos;--height&apos;, type = int, default = 80) #输出字符画高 args = parser.parse_args() #获取参数 IMG = args.file WIDTH = args.width HEIGHT = args.height OUTPUT = args.output ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~&lt;&gt;i!lI;:,\&quot;^`&apos;. &quot;) def get_char(r,g,b,alpha = 256): # 将256灰度映射到70个字符上 if alpha == 0: return &apos; &apos; length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)] if __name__ == &apos;__main__&apos;: im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) txt = &quot;&quot; for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) txt += &apos;\n&apos; print txt if OUTPUT: #字符画输出到文件 with open(OUTPUT,&apos;w&apos;) as f: f.write(txt) else: with open(&quot;output.txt&quot;,&apos;w&apos;) as f: f.write(txt) 运行程序默认输出文件名output.txt，图片默认高宽80 python image_ascii.py image.jpg 也可以这样制定输出文件名和高宽 python image_ascii.py image.jpg -o put.txt --width 40 --height 40 效果图自己的照片对应的字符画 网上找的卡通照片原图以及对应的字符画]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flask-admin使用经验技巧总结]]></title>
      <url>%2F2017%2F01%2F22%2FFlask-admin%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[前段时间自学了Flask框架，看得狗书入门，最近做一个新闻发布网站准备拿Flask来做，尝试一下Flask快速开发，并且练练手，于是接触到了Flask-admin。总结一下Flask-admin 首先需要导入的包from flask_admin import Admin,BaseView,expose,AdminIndexView from flask_admin.contrib.sqla import ModelView 效果图 模型视图 管理新闻、管理公告、管理文件、管理展示栏是四个与数据库表同步的模型视图，如果你想要在后台管理程序中数据库中的表在初始化admin后仅需一句代码 admin = Admin(app) admin.add_view(ModelView(User, db.session))&apos; 但是有时候flask-admin的默认设置并不能满足你的条件，如果我们在后台只打算让表中固定的几列数据显示,这时候我们就不能直接像上面那样直接ModelView，我们需自定义一个类并继承ModelView，并重写一些代码，把想要显示出来的列名写在column_list中 class MyV1(ModelView): column_list = (&apos;id&apos;, &apos;title&apos;,&apos;timestamp&apos;,&apos;count&apos;,&apos;content&apos;) def __init__(self, session, **kwargs): super(MyV1, self).__init__(News, session, **kwargs) 然后在程序中再加入代码如下，然后就OK了 admin.add_view(MyV1(db.session,name = u&apos;管理新闻&apos;)) 如果我们使用flask做网站是给自己使用，后台和数据库中同步的列名是英文显示没有多大影响，自己写的数据库难道还不知道什么意思，但是当我们是写给非技术人员使用时，他们可能不能理解每个列名是什么意思，所以现在我们就需要将列名中文化，也是需要重写column_labels class MyV1(ModelView): column_labels = { &apos;id&apos;:u&apos;序号&apos;, &apos;title&apos; : u&apos;新闻标题&apos;, &apos;timestamp&apos;:u&apos;发布时间&apos;, &apos;count&apos;:u&apos;浏览次数&apos;, &apos;content&apos;:u&apos;新闻内容&apos; } column_list = (&apos;id&apos;, &apos;title&apos;,&apos;timestamp&apos;,&apos;count&apos;,&apos;content&apos;) def __init__(self, session, **kwargs): super(MyV1, self).__init__(News, session, **kwargs) 有时候当同步数据库表成功后，扩展会有一个默认新建数据插入数据库表中的功能，但是我们有时候发表博客、新闻这些需要排版的文章但是默认的新建数据不支持这个功能怎么办，我们可以把默认创建功能先关掉。 class MyV1(ModelView): can_create = False column_labels = { &apos;id&apos;:u&apos;序号&apos;, &apos;title&apos; : u&apos;新闻标题&apos;, &apos;timestamp&apos;:u&apos;发布时间&apos;, &apos;count&apos;:u&apos;浏览次数&apos;, &apos;content&apos;:u&apos;新闻内容&apos; } column_list = (&apos;id&apos;, &apos;title&apos;,&apos;timestamp&apos;,&apos;count&apos;,&apos;content&apos;) def __init__(self, session, **kwargs): super(MyV1, self).__init__(News, session, **kwargs) 创建视图 上面我们说到讲默认创建功能关掉，但是我们怎么新建数据呢，我们可以自己写一个视图，关联自己的模板，再在模板中集成富文本。 class MyNews(BaseView): @expose(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]) def index(self): form = NameForm() return self.render(&apos;donews.html&apos;, form=form) 然后再程序中加入代码 admin.add_view(MyNews(name=u&apos;发表新闻&apos;)) 对主页面的修改 Flask-admin默认主页面标题是Home，而且界面一片空白，由于各种需要，我们需要对这些进行更改，参考以下代码复制代码 admin = Admin( app, index_view=AdminIndexView( name=&apos;导航栏&apos;, template=&apos;welcome.html&apos;, url=&apos;/admin&apos; ) ) 将标题修改为导航栏，并将主页设置为welcome.html，进入后台对应的url也可以修改 权限设置 一般后台并不是对所有用户开放的，所有牵扯到了管理员权限，这一块我是依靠flask-login这个扩展实现的，关于flask-login会再写一遍进行总结，新加代码如下 class MyNews(BaseView): def is_accessible(self): if current_user.is_authenticated and current_user.username == &quot;admin&quot;: return True return False @expose(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]) def index(self): form = NameForm() return self.render(&apos;donews.html&apos;, form=form) 通过判断当前用户登录状态和当前登录的用户名进行权限设置]]></content>
    </entry>

    
  
  
</search>
