<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MagicRoc</title>
  <subtitle>把伞祝东风，且共从容</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.magicroc.com/"/>
  <updated>2017-04-05T12:36:23.949Z</updated>
  <id>www.magicroc.com/</id>
  
  <author>
    <name>MagicRoc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flask+uWSGI+Nginx部署笔记</title>
    <link href="www.magicroc.com/2017/04/05/Flask-uWSGI-Nginx%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/"/>
    <id>www.magicroc.com/2017/04/05/Flask-uWSGI-Nginx部署笔记/</id>
    <published>2017-04-05T11:19:53.000Z</published>
    <updated>2017-04-05T12:36:23.949Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>其实简单部署Flask程序很简单，只要掌握了流程和每一层的作用。本来应该再加上Supervisor，不过我还没有尝试，先总结下来uWSGI和Nginx以及遇到的一些小问题以及解决办法</strong></p>
</blockquote>
<a id="more"></a>
<p><img src="4.jpg" alt="配图"></p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p> <strong>本地环境：Ubuntu16.04<br> 服务器：Centos7.0<br> Python: 2.7.5</strong></p>
<h1 id="安装SSH"><a href="#安装SSH" class="headerlink" title="安装SSH"></a>安装SSH</h1><pre><code>sudo apt-get install openssh-server
</code></pre><h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><pre><code>sudo vi /etc/ssh/sshd_config
</code></pre><p>禁用：PermitRootLogin prohibit-password<br>添加：PermitRootLogin yes</p>
<p><strong>重启</strong></p>
<pre><code>sudo service ssh restart
</code></pre><h2 id="ssh使用"><a href="#ssh使用" class="headerlink" title="ssh使用"></a>ssh使用</h2><pre><code>ssh root@远程服务器IP
</code></pre><h2 id="scp使用"><a href="#scp使用" class="headerlink" title="scp使用"></a>scp使用</h2><p><strong>scp: 跨机远程拷贝</strong></p>
<h3 id="从本地到远程服务器"><a href="#从本地到远程服务器" class="headerlink" title="从本地到远程服务器"></a>从本地到远程服务器</h3><pre><code>scp 本地文件 远程服务器用户名@远程服务器IP:远程服务器目录
</code></pre><h3 id="从远程服务器下载到本地"><a href="#从远程服务器下载到本地" class="headerlink" title="从远程服务器下载到本地"></a>从远程服务器下载到本地</h3><pre><code>scp 远程服务器用户名@远程服务器IP:远程服务器文件 本地目录
</code></pre><p><strong>如果是目录则在scp后加-r参数即可</strong></p>
<h1 id="配置Flask"><a href="#配置Flask" class="headerlink" title="配置Flask"></a>配置Flask</h1><h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h2><pre><code>sudo yum –y install epel-release
sudo yum –y install python-pip
</code></pre><h2 id="安装virtualenv"><a href="#安装virtualenv" class="headerlink" title="安装virtualenv"></a>安装virtualenv</h2><pre><code>pip install virtualenv
</code></pre><p>在应用程序目录创建虚拟环境 virtualenv venv<br>激活虚拟环境: source /venv/bin/activate</p>
<h2 id="安装flask应用程序依赖包"><a href="#安装flask应用程序依赖包" class="headerlink" title="安装flask应用程序依赖包"></a>安装flask应用程序依赖包</h2><p>因为pip安装时速度太慢，所以决定更改为pip国内源<br>对指定包对安装临时使用豆瓣源</p>
<pre><code>pip install flask_sqlalchemy –i http://pypi.douban.com/simple
</code></pre><p>永久更新源办法  修改配置文件<br>在主目录下创建.pip文件夹</p>
<pre><code>mkdir ~/.pip
</code></pre><p>　　　　<br>然后在该目录下创建pip.conf文件</p>
<pre><code>vim pip.conf
</code></pre><p>写入以下内容<br>　　　<br>    [global]<br>    trusted-host = pypi.douban.com<br>    index-url = <a href="http://pypi.douban.com/simple" target="_blank" rel="external">http://pypi.douban.com/simple</a></p>
<h1 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h1><pre><code>sudo yum install nginx
</code></pre><h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><pre><code>vim etc/nginx/nginx.conf
</code></pre><p>修改如下</p>
<pre><code>server {
 　　　　 listen  80;
  　　　　server_name XXX.XXX.XXX; #公网地址

　　　　  location / {
　　　　include      uwsgi_params;
　　　　uwsgi_pass   127.0.0.1:8001;  # 指向uwsgi 所应用的内部地址,所有请求将转发给uwsgi 处理
　　　　uwsgi_param UWSGI_PYHOME /root/School/venv; # 指向虚拟环境目录
　　　　uwsgi_param UWSGI_CHDIR  /root/School; # 指向网站根目录
　　　　uwsgi_param UWSGI_SCRIPT manage:app; # 指定启动程序
 　　　　 }
}
</code></pre><h2 id="Nginx简单指令"><a href="#Nginx简单指令" class="headerlink" title="Nginx简单指令"></a>Nginx简单指令</h2><p> 启动nginx：<br> 命令行输入nginx或者nginx -c nginx配置文件</p>
<p>关闭nginx：<br>ps -ef|grep nginx查看nginx 线程ID<br>kill -QUIT 线程ID</p>
<p><strong>Nginx出现413 Request Entity Too Large错误解决方法</strong><br>打开nginx主配置文件nginx.conf,找到http{}段，修改或者添加</p>
<pre><code>client_max_body_size 4m;
</code></pre><h1 id="安装uWSGI"><a href="#安装uWSGI" class="headerlink" title="安装uWSGI"></a>安装uWSGI</h1><p>需安装三个库:</p>
<pre><code>1.sudo yum install libxml2
2.sudo yum install gcc
3.sudo yum install python-devel
</code></pre><p>然后:</p>
<pre><code>pip  install uwsgi 
</code></pre><h2 id="配置uWSGI"><a href="#配置uWSGI" class="headerlink" title="配置uWSGI"></a>配置uWSGI</h2><p>进入flask应用程序目录 </p>
<pre><code>vim config.ini
</code></pre><p>编辑:</p>
<pre><code>[uwsgi]
# uwsgi 启动时所使用的地址与端口
socket = 127.0.0.1:8001 
# 指向网站目录
chdir = /root/School 
# python 启动程序文件
wsgi-file = manage.py 
# python 程序内用以启动的 application 变量名
callable = app 
# 处理器数
processes = 4
# 线程数
threads = 2
#状态检测地址
stats = 127.0.0.1:9191
</code></pre><h2 id="uWSGI命令"><a href="#uWSGI命令" class="headerlink" title="uWSGI命令"></a>uWSGI命令</h2><p>uwsgi 启动 ：虚拟环境下uwsgi config.ini<br>uwsgi 关闭：虚拟环境下killall -9 uwsgi</p>
<h1 id="部署说明"><a href="#部署说明" class="headerlink" title="部署说明"></a>部署说明</h1><p><img src="1.png" alt="部署图"></p>
<ul>
<li>uWSGI 提高并发访问支持，提高服务运行稳定性</li>
<li>Nginx在这里最基本的一个用处就是转发：当客户访问一个域名或者IP时 Nginx就将访问转发给uwsgi处理</li>
<li>Supervisor可以同时启动多个应用，更重要的是，当某个应用Crash的时候，它可以自动重启该应用，保证可用性</li>
</ul>
<p>这样uwsgi可以让supervisor帮助启动，而且当uwsgi Crash时会尝试帮重启它，保证uwsgi和网站的可用性</p>
<blockquote>
<p><strong>如何理解Nginx, WSGI, Flask之间的关系 ? 这是一篇很好的文章<br> <a href="http://blog.csdn.net/lihao21/article/details/52304119" target="_blank" rel="external">http://blog.csdn.net/lihao21/article/details/52304119</a></strong></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;其实简单部署Flask程序很简单，只要掌握了流程和每一层的作用。本来应该再加上Supervisor，不过我还没有尝试，先总结下来uWSGI和Nginx以及遇到的一些小问题以及解决办法&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="实践经验" scheme="www.magicroc.com/categories/%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="Flask" scheme="www.magicroc.com/tags/Flask/"/>
    
      <category term="Python" scheme="www.magicroc.com/tags/Python/"/>
    
      <category term="uWSGI" scheme="www.magicroc.com/tags/uWSGI/"/>
    
      <category term="Nginx" scheme="www.magicroc.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Everymail自动邮件的设计与实现</title>
    <link href="www.magicroc.com/2017/03/24/Everymail%E8%87%AA%E5%8A%A8%E9%82%AE%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>www.magicroc.com/2017/03/24/Everymail自动邮件的设计与实现/</id>
    <published>2017-03-24T06:26:52.000Z</published>
    <updated>2017-03-24T07:29:22.358Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong> 很简单的一个python写的程序，每天早晨六点自动发送邮件到指定邮箱，邮件内容包括当地天气、笑话、英语单词。天气和笑话通过调用API，英语单词通过文件读取</strong></p>
</blockquote>
<a id="more"></a>
<p><img src="1.png" alt="配图"></p>
<h1 id="首先实现邮件发送"><a href="#首先实现邮件发送" class="headerlink" title="首先实现邮件发送"></a>首先实现邮件发送</h1><p>通过email 和 smtplib实现,需要导入的库</p>
<pre><code>from email import encoders
from email.header import Header
from email.mime.text import MIMEText
from email.utils import parseaddr, formatadd
import smtplib
</code></pre><p>设置邮箱表标题，发件人，收件人，以及邮箱内容</p>
<pre><code>msg = MIMEText(location+temp+weather+weatime+jokeall+jokeword, &apos;plain&apos;,&apos;utf-8&apos;)
msg[&apos;From&apos;] = _format_addr(&apos;Everymail &lt;%s&gt;&apos; % from_addr)
msg[&apos;To&apos;] = _format_addr(&apos;管理员 &lt;%s&gt;&apos; % to_addr)
msg[&apos;Subject&apos;] = Header(&apos;The New day&apos;, &apos;utf-8&apos;).encode()
</code></pre><p>生成实例，登录发送</p>
<pre><code>server = smtplib.SMTP(smtp_server, 25)
server.set_debuglevel(1)
server.login(from_addr, password)
server.sendmail(from_addr, [to_addr], msg.as_string())
server.quit()
</code></pre><p>接下的只要任务是获取MIMEText中的那些参数<br><strong>location ：当地位置<br>temp：当地温度<br>weather：当地天气<br>weatime：天气更新时间<br>jokeword：十个单词<br>jokeall：一个笑话</strong></p>
<h1 id="天气的获取"><a href="#天气的获取" class="headerlink" title="天气的获取"></a>天气的获取</h1><p>程序调用的是心知天气的API</p>
<pre><code>def fetchWeather():

    location = getLocation()
    result = requests.get(API, params={
    &apos;key&apos;: KEY,
    &apos;location&apos;: location,
    &apos;language&apos;: LANGUAGE,
    &apos;unit&apos;: UNIT
    }, timeout=100)
    values = json.loads(result.text)
    results = values[&quot;results&quot;][0]
    wea = results[&quot;now&quot;]
    time = re.sub(r&apos;([\d|-]+)T([\d|:]+).+&apos;, r&apos;\1 \2&apos;, results[&quot;last_update&quot;])
    return wea,time
</code></pre><p>通过json.loads将返回的json数据解析，然后一层一层的取出，天气，温度，和时间。因为返回的时间格式一点不适合查看，故用正则将其转化为常见的时间格式</p>
<h1 id="笑话的获取"><a href="#笑话的获取" class="headerlink" title="笑话的获取"></a>笑话的获取</h1><p>程序调用的是来福岛的笑话接口</p>
<pre><code>def fetchjoke():
    showapi_appid = id  #替换此值
    showapi_sign = key  #替换此值
    url=&quot;http://route.showapi.com/341-1&quot;
    send_data = parse.urlencode([
    (&apos;showapi_appid&apos;, showapi_appid)
    ,(&apos;showapi_sign&apos;, showapi_sign)
                ,(&apos;time&apos;, &quot;&quot;)
                ,(&apos;page&apos;, &quot;&quot;)
                ,(&apos;maxResult&apos;, &quot;&quot;)

  ])
    req = request.Request(url)
    with request.urlopen(req, data=send_data.encode(&apos;utf-8&apos;)) as f:
    str_res= f.read().decode(&apos;utf-8&apos;)
    json_res=json.loads(str_res)
    a = 1
    joketitle = []
    jokecontext = []
    jokeall = &quot;&quot;
    for i in json_res[&apos;showapi_res_body&apos;].get(&quot;contentlist&quot;):
        joketitle.append(i[&quot;title&quot;])
        jokecontext.append(i[&quot;text&quot;])
        jokeall = jokeall + &apos;标题 : &apos; + i[&quot;title&quot;] + &apos;\n&apos;
        jokeall = jokeall + &apos;内容 : \n&apos; + i[&quot;text&quot;] + &apos;\n\n&apos;
        a+=1
        break
    return(jokeall)
</code></pre><p>也是通过json.loads解析返回的json数据，然后取出所需要的数据，作为函数返回数据</p>
<h1 id="单词的获取"><a href="#单词的获取" class="headerlink" title="单词的获取"></a>单词的获取</h1><p>单词是从一个txt文件按顺序读取的，之前把四级单词全部复制进去。但是有时候程序可能crash，重新启动程序的时候可能又要从第一个单词开始读取了，所以又多了一个文件用来记录每次读取的位置</p>
<pre><code>def fetchword():
    theword = &quot;&quot;
    with open(&apos;value.txt&apos;,&quot;r&quot;) as f1,open(&apos;recoad.txt&apos;,&quot;r&quot;) as f2:
    flag = f2.read()
    count = 1
    for i in f1:
        count+=1
        if (count &gt;= int(flag)):
            theword = theword + str(i) + &quot;\n&quot;;
            if(count == int(flag)+10):
                break
    with open(&quot;recoad.txt&quot;,&quot;w&quot;) as f:
    f.write(str(int(flag)+10))
    return theword
</code></pre><h1 id="定时发送"><a href="#定时发送" class="headerlink" title="定时发送"></a>定时发送</h1><pre><code>import threading
import time
from sendmail import send
def outosend():
    send()
    global t    #Notice: use global variable!
    t = threading.Timer(86400.0, outosend)    # 定时器
    t.start()
t = threading.Timer(5.0, outosend)
while 1:
    if time.localtime()[3] == 6:  # 判断现在是不是早晨六点
    t.start()   
    break     # 线程不能重复开始，不然会有警告
</code></pre><p>通过Timer定时器实现每86400秒（一天）发送一次，通过递归实现程序一直运行此函数。<br>但是为了保证在六点发送，然后下一次发送也是六点，所有通过time.localtime判断现在的时间是不是到六点，一旦正确，线程开始启动</p>
<h2 id="同时发送多个邮箱"><a href="#同时发送多个邮箱" class="headerlink" title="同时发送多个邮箱"></a>同时发送多个邮箱</h2><p>为了保证同时发送多个邮箱，所以把要发送的邮箱写入了文件，然后通过文件一个一个的读取</p>
<pre><code>with open(&quot;emails.txt&quot;,&quot;r&quot;) as f:
    emails = f.readlines()


    for to_addr in emails:
    msg[&apos;To&apos;] = _format_addr(&apos;管理员 &lt;%s&gt;&apos; % to_addr)
</code></pre><p><img src="3.png" alt=" 结果图"> <img src="4.png" alt=" 结果图"> </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt; 很简单的一个python写的程序，每天早晨六点自动发送邮件到指定邮箱，邮件内容包括当地天气、笑话、英语单词。天气和笑话通过调用API，英语单词通过文件读取&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="实践经验" scheme="www.magicroc.com/categories/%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="Python" scheme="www.magicroc.com/tags/Python/"/>
    
      <category term="SMTP" scheme="www.magicroc.com/tags/SMTP/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫初探（二）</title>
    <link href="www.magicroc.com/2017/03/13/Python%E7%88%AC%E8%99%AB%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>www.magicroc.com/2017/03/13/Python爬虫初探（二）/</id>
    <published>2017-03-13T08:29:53.000Z</published>
    <updated>2017-03-13T13:22:21.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong> 相对于系列一做了一些简单的改进，主要是由于科四有图片和动图之分，并且有时候程序会暂停，但不报错，所以一直在想断点继续问题，当然效率依旧低。见谅</strong></p>
</blockquote>
<a id="more"></a>
<p><img src="2.jpg" alt="配图"></p>
<h1 id="同时爬取图片和动图问题"><a href="#同时爬取图片和动图问题" class="headerlink" title="同时爬取图片和动图问题"></a>同时爬取图片和动图问题</h1><p>因为科目四有的题目包含动图，要爬取的网站是做成mov格式的短视频<br>例如：</p>
<pre><code>&lt;div class=&quot;test-r f-r&quot;&gt;
                      &lt;video src=&quot;http://www.jiazhao.com/images/tiku/201511231357033827.mov&quot; controls=&quot;controls&quot;&gt;您的浏览器不支持不放&lt;/video&gt;&lt;!-- &lt;a href=&quot;javascript:;&quot; class=&quot;t-big&quot;&gt;点击放大观看&lt;/a&gt; --&gt;   
</code></pre><h2 id="增加获取视频链接"><a href="#增加获取视频链接" class="headerlink" title="增加获取视频链接"></a>增加获取视频链接</h2><p>系列一获取图片的方法是在获取选项、答案的基础上再次传到BeautifulSoup对象，然后再次提取img标签，如果某题没有图片，提取的则是一个空值，此处提取img和video标签。如果某题没有图片或视频，提取的则是一个空值。只需改一句代码</p>
<pre><code>img = soup.find_all([&apos;img&apos;,&apos;video&apos;])
</code></pre><h1 id="获取图片或动图后缀"><a href="#获取图片或动图后缀" class="headerlink" title="获取图片或动图后缀"></a>获取图片或动图后缀</h1><p>系列一中为了方便直接在文件名后面加的字符串形式.png后缀，但是现在要解决后缀不一致（写代码尽可能还是不要偷懒…）<br>解决代码：</p>
<pre><code>if img:
    for im in img:
        src = im.get(&apos;src&apos;)
        suffix = src.split(&apos;.&apos;)[3] 
        filename = str(i) + &apos;.&apos; + suffix
</code></pre><p>如果此题有图片或动图，则把这个图的链接通过’.’进行分割。最后的元素则是后缀</p>
<h1 id="争取实现断点继续"><a href="#争取实现断点继续" class="headerlink" title="争取实现断点继续"></a>争取实现断点继续</h1><p>不知道为什么程序会暂停不动，模仿浏览器，捕获异常都试了，依然不行，所以我尽可能的实现断点继续。<br>每个图片对应一个链接，难免有一个链接卡住（我猜测的）<br><strong>  解决办法 : </strong><br>在我们得到链接，并生成文件名后，先不去打开这个这个链接，先根据文件名判断这个图片是否文件夹中已经包含，如果包含扔掉这个链接，去继续下一个链接</p>
<pre><code>if img:
    for im in img:
        src = im.get(&apos;src&apos;)
        suffix = src.split(&apos;.&apos;)[3] 
        filename = str(i) + &apos;.&apos; + suffix
        if os.path.exists(&apos;picture/&apos;+filename):
            break
        saveImg(im.get(&apos;src&apos;),filename)
</code></pre><p><img src="1.png" alt="文件图"></p>
<h1 id="题目解析的爬取"><a href="#题目解析的爬取" class="headerlink" title="题目解析的爬取"></a>题目解析的爬取</h1><p><strong>思路</strong><br>    1.将所以题目的解析链接爬取出去单独存放到一个文件。<br>    2.为了解决有些链接一次进不去必须中断程序再次开始，和存储图片思路一样，争取实现断点继续，<br>    3.但是写入文件和保存图片还是不一样，针对面临的情况，初步解决想法为每抽取一条链接的解析，就删掉这个链接，用列表存储从链接文件中读取的链接</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt; 相对于系列一做了一些简单的改进，主要是由于科四有图片和动图之分，并且有时候程序会暂停，但不报错，所以一直在想断点继续问题，当然效率依旧低。见谅&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="基础学习" scheme="www.magicroc.com/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="www.magicroc.com/tags/Python/"/>
    
      <category term="爬虫" scheme="www.magicroc.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫初探（一）</title>
    <link href="www.magicroc.com/2017/03/12/Python%E7%88%AC%E8%99%AB%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>www.magicroc.com/2017/03/12/Python爬虫初探（一）/</id>
    <published>2017-03-12T12:49:02.000Z</published>
    <updated>2017-03-13T13:27:56.433Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong> 最近参与了的一个项目，因为项目需要驾照考试科一和科四的完整题库，网上找了好久找不到完整版题库，所以才有了这篇博客的由来，因为技术不太好，之前学习的又是Python web相关的知识，所以关于程序的代码可能有些繁琐、低效。见谅</strong></p>
</blockquote>
<a id="more"></a>
<p><img src="3.jpg" alt="配图"></p>
<h1 id="分析得到标题、选项和答案"><a href="#分析得到标题、选项和答案" class="headerlink" title="分析得到标题、选项和答案"></a>分析得到标题、选项和答案</h1><p>首先看一下要爬取的网页源码内容，科目一共有四章，第一章有30页，每页二十道题，这是第一章第一页的第一题</p>
<pre><code>&lt;a href=&quot;/tiba/9294/&quot; target=&quot;_blank&quot;&gt;
              &lt;div class=&quot;ui-test clearfix titem&quot;&gt;
                   &lt;p class=&quot;title&quot;&gt;1、&amp;nbsp;如图所示，A车在此处停车是可以的。&lt;/p&gt;
                                             &lt;!--判断--&gt;
                       &lt;div class=&quot;test-bd f-l&quot;&gt;
                           &lt;ul&gt;
                                &lt;li&gt;A、正确&lt;/li&gt;
                                &lt;li&gt;B、错误&lt;/li&gt;
                                &lt;li class=&quot;answer&quot;&gt;&lt;strong class=&quot;right&quot;&gt;答案：&lt;/strong&gt; &lt;strong&gt;对&lt;/strong&gt;&lt;span style=&quot;margin-left:100px;display:inline-block;&quot;&gt;查看分析&lt;/span&gt;&lt;/li&gt;
                           &lt;/ul&gt;
                        &lt;/div&gt;
                                            &lt;div class=&quot;test-r f-r&quot;&gt;
                      &lt;img src=&quot;http://www.jiazhao.com/images/tiku/1436112505.png&quot; &gt;&lt;!-- &lt;a href=&quot;javascript:;&quot; class=&quot;t-big&quot;&gt;查看大图&lt;/a&gt; --&gt;                        &lt;/div&gt;
              &lt;/div&gt;
              &lt;/a&gt;
</code></pre><h2 id="获取标题"><a href="#获取标题" class="headerlink" title="获取标题"></a>获取标题</h2><p><strong>思考</strong></p>
<ul>
<li>利用urllib.request.urlopen获取网页HTML内容</li>
<li>将HTML内容传到BeautifulSoup对象</li>
<li><p>从对象里提取class为’title’的p标签</p>
<p>  from urllib.request import urlopen<br>  from bs4 import BeautifulSoup<br>  for n in range(1,31):</p>
<pre><code>url = &apos;www.××××××.com&apos; + str(n)
html = urlopen(url)
soup = BeautifulSoup(html,&apos;lxml&apos;)
titlelist = soup.findAll(&quot;p&quot;,{&quot;class&quot;:&quot;title&quot;})
</code></pre></li>
</ul>
<p>现在得到了第一章的所有题目标题的列表。</p>
<h2 id="获取选项和答案"><a href="#获取选项和答案" class="headerlink" title="获取选项和答案"></a>获取选项和答案</h2><p>选项和答案同样思路</p>
<ul>
<li><p>从对象中查找class 为”test-bd f-l”的div标签</p>
<p>  chooselist = bs0bj.findAll(“div”,{“class”:”test-bd f-l”})</p>
</li>
</ul>
<h2 id="使用for循环同时遍历两个列表"><a href="#使用for循环同时遍历两个列表" class="headerlink" title="使用for循环同时遍历两个列表"></a>使用for循环同时遍历两个列表</h2><pre><code>for title,choose,jiexi in zip(titlelist,chooselist):
    print(title.get_text())
    print(choose.get_text()) 
</code></pre><p>此时将会输出第一章所有的标题、选项和答案</p>
<p><strong>  zip:因为要同时遍历两个列表，接受一系列可迭代对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。<br>get_text():把正在处理的HTML文档中的所有标签都清楚，然后返回一个只包含文字的字符串</strong></p>
<h1 id="将得到数据写入文件，并做简单处理"><a href="#将得到数据写入文件，并做简单处理" class="headerlink" title="将得到数据写入文件，并做简单处理"></a>将得到数据写入文件，并做简单处理</h1><h2 id="将标题、选项、答案写入文件"><a href="#将标题、选项、答案写入文件" class="headerlink" title="将标题、选项、答案写入文件"></a>将标题、选项、答案写入文件</h2><pre><code>with open(&apos;tiku1.txt&apos;,&apos;w&apos;) as file:
    ***
    ***
    ***
    for title,choose,jiexi in zip(titlelist,chooselist):
        file.write(title.get_text())
        file.write(choose.get_text()) 
</code></pre><p>文件中包含第一章所有试题，不足之处是多了四个字”查看解析”<br>    <img src="1.png" alt="文件图"></p>
<h2 id="使用空值替换多余字符"><a href="#使用空值替换多余字符" class="headerlink" title="使用空值替换多余字符"></a>使用空值替换多余字符</h2><p>解决办法：<br>    将文件中的数据全部读取出来赋值到字符串a<br>    使用字符串替换，使用空值替换掉“查看解析”<br>    将替换好的字符串写到另一个新文件</p>
<pre><code># -*- coding:utf-8 -*-
  with open(&apos;tiku1.txt&apos;,&apos;r&apos;) as f1:
      a = f1.read()
  b = a.replace(&apos;查看分析&apos;,&apos;&apos;)
  with open(&apos;newtiku1.txt&apos;,&apos;w&apos;) as f2:
      f2.write(b)
</code></pre><h1 id="题目对应图片的爬取"><a href="#题目对应图片的爬取" class="headerlink" title="题目对应图片的爬取"></a>题目对应图片的爬取</h1><h2 id="解决图片对应题号问题"><a href="#解决图片对应题号问题" class="headerlink" title="解决图片对应题号问题"></a>解决图片对应题号问题</h2><p>  ** 思考，并不是每道题都附带图片，但是图片的命名必须要和题号对应起来，所以，在获取选项、答案的基础上再次传到BeautifulSoup对象，然后再次提取img标签，如果某题没有图片，提取的则是一个空值</p>
<pre><code>from urllib.request import urlopen
from savepic import saveImg
from bs4 import BeautifulSoup
i = 1
for n in range(1,30):
    url = &quot;www.××××××.com&quot;+ str(n)
    html = urlopen(url)
    bs0bj = BeautifulSoup(html,&apos;lxml&apos;)
    chooselist = bs0bj.findAll(&quot;div&quot;,{&quot;class&quot;:&quot;ui-test clearfix titem&quot;})
    for choose in chooselist:
        soup = BeautifulSoup(str(choose),&quot;lxml&quot;)
        img = soup.find_all([&apos;img&apos;])
        if img:
            for im in img:
                filename = str(i)+&apos;.png&apos;
                saveImg(im.get(&apos;src&apos;),filename)
                print(&quot;保存第{0}题的图片&quot;.format(i))
        else:
            print(&apos;第{0}题没有图片&apos;.format(i))
</code></pre><h2 id="图片保存"><a href="#图片保存" class="headerlink" title="图片保存"></a>图片保存</h2><pre><code>from urllib.request import urlopen
def saveImg(imageURL,fileName):
    u = urlopen(imageURL)
    data = u.read()
    with open(&apos;picture/&apos;+fileName, &apos;wb&apos;) as f:
        f.write(data)
</code></pre><p>和写入字符串到文件类似，不过这里是以二进制方式写入图片流<br>    <img src="2.png" alt="文件图"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt; 最近参与了的一个项目，因为项目需要驾照考试科一和科四的完整题库，网上找了好久找不到完整版题库，所以才有了这篇博客的由来，因为技术不太好，之前学习的又是Python web相关的知识，所以关于程序的代码可能有些繁琐、低效。见谅&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="基础学习" scheme="www.magicroc.com/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="www.magicroc.com/tags/Python/"/>
    
      <category term="爬虫" scheme="www.magicroc.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>详细解读14行代码实现字母算术</title>
    <link href="www.magicroc.com/2017/02/27/%E8%AF%A6%E7%BB%86%E8%A7%A3%E8%AF%BB14%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%AD%97%E6%AF%8D%E7%AE%97%E6%9C%AF/"/>
    <id>www.magicroc.com/2017/02/27/详细解读14行代码实现字母算术/</id>
    <published>2017-02-27T13:23:36.000Z</published>
    <updated>2017-03-13T13:42:42.649Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>HAWAII + IDAHO + IOWA + OHIO == STATES<br>510199 + 98153 + 9301 + 3593 == 621246<br>What is this ？
</strong></p>
</blockquote>
<a id="more"></a>
<p><img src="3.png" alt="配图"></p>
<p><strong>HAWAII + IDAHO + IOWA + OHIO == STATES<br>510199 + 98153 + 9301 + 3593 == 621246<br>H = 5<br>A = 1<br>W = 0<br>I = 9<br>D = 8<br>O = 3<br>S = 6<br>T = 2<br>E = 4</strong></p>
<p>像这样的谜题被称为cryptarithms 或者 字母算术(alphametics)。字母可以拼出实际的单词，而如果你把每一个字母都用0–9中的某一个数字代替后, 也同样可以拼出 一个算术等式。关键的地方是找出每个字母都映射到了哪个数字。每个字母所有出现的地方都必须映射到同一个数字，数字不能重复, 并且“单词”不能以0开始。</p>
<p><strong> 这是&lt;&lt;深入Python3&gt;&gt;上对高级迭代器讲解的例子，仅仅14行代码但有很多知识</strong></p>
<h1 id="使用re-findall-找出出现的所有字符"><a href="#使用re-findall-找出出现的所有字符" class="headerlink" title="使用re.findall()找出出现的所有字符"></a>使用re.findall()找出出现的所有字符</h1><pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; puzzle = &apos;HAWAII + IDAHO + IOWA + OHIO == STATES&apos;
&gt;&gt;&gt; re.findall(&apos;[A-Z]+&apos;, puzzle.upper())
[&apos;HAWAII&apos;, &apos;IDAHO&apos;, &apos;IOWA&apos;, &apos;OHIO&apos;, &apos;STATES&apos;]
</code></pre><p><strong>解读</strong>：</p>
<ul>
<li>[A-Z] A-Z中的一个字符</li>
<li>匹配指定字符1次或多次</li>
<li>puzzle.upper() 将puzzle字符串所有字符大写</li>
<li>re.findall() findall() 接受一个正则表达式和一个字符串作为参数，然后找出字符串中出现该模式的所有地方</li>
</ul>
<h1 id="使用join连接元素使用set过滤重复字符"><a href="#使用join连接元素使用set过滤重复字符" class="headerlink" title="使用join连接元素使用set过滤重复字符"></a>使用join连接元素使用set过滤重复字符</h1><pre><code>&gt;&gt;&gt; words
[&apos;HAWAII&apos;, &apos;IDAHO&apos;, &apos;IOWA&apos;, &apos;OHIO&apos;, &apos;STATES&apos;]
&gt;&gt;&gt; &apos;&apos;.join(words)
&apos;HAWAIIIDAHOIOWAOHIOSTATES&apos;
&gt;&gt;&gt; set(&apos;&apos;.join(words))
{&apos;H&apos;, &apos;T&apos;, &apos;S&apos;, &apos;W&apos;, &apos;D&apos;, &apos;I&apos;, &apos;O&apos;, &apos;E&apos;, &apos;A&apos;}
</code></pre><p><strong>解读</strong></p>
<ul>
<li>Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。此处以空字符连接words序列</li>
<li>set集合中是无序不重复元素集</li>
</ul>
<h1 id="通过assert防止出现的字母超过十种"><a href="#通过assert防止出现的字母超过十种" class="headerlink" title="通过assert防止出现的字母超过十种"></a>通过assert防止出现的字母超过十种</h1><pre><code>&gt;&gt;&gt; unique_characters
{&apos;H&apos;, &apos;T&apos;, &apos;S&apos;, &apos;W&apos;, &apos;D&apos;, &apos;I&apos;, &apos;O&apos;, &apos;E&apos;, &apos;A&apos;}
&gt;&gt;&gt; len(unique_characters)
9
&gt;&gt;&gt; assert len(unique_characters) &lt;= 10, &apos;Too many letters&apos;
&gt;&gt;&gt; assert 1&gt;2, &apos;you are silly&apos;
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AssertionError: you are silly
</code></pre><p><strong>解读</strong></p>
<ul>
<li>len()计算列表、元祖、字符串等序列的长度</li>
<li>assert assert语句用来声明某个条件是真的，、当assert语句失败的时候，会引发异常AssertionError， 可以自己在语句后面添加报错输出信息</li>
</ul>
<h1 id="通过集合推导获取每个输入字符的首字母并过滤重复"><a href="#通过集合推导获取每个输入字符的首字母并过滤重复" class="headerlink" title="通过集合推导获取每个输入字符的首字母并过滤重复"></a>通过集合推导获取每个输入字符的首字母并过滤重复</h1><pre><code>&gt;&gt;&gt; words
[&apos;HAWAII&apos;, &apos;IDAHO&apos;, &apos;IOWA&apos;, &apos;OHIO&apos;, &apos;STATES&apos;]
&gt;&gt;&gt; {word[0] for word in words}
{&apos;H&apos;, &apos;S&apos;, &apos;I&apos;, &apos;O&apos;}
&gt;&gt;&gt; first_letters = {word[0] for word in words}
&gt;&gt;&gt; len(first_letters)
4
</code></pre><p><strong>解读</strong></p>
<ul>
<li>此处是集合推导， 获取输入的字符串的第一个字母，并把重复出现的字母过滤掉</li>
</ul>
<h1 id="对所有出现的字母进行组合-要将每个字符串的首字母放在最前面"><a href="#对所有出现的字母进行组合-要将每个字符串的首字母放在最前面" class="headerlink" title="对所有出现的字母进行组合(要将每个字符串的首字母放在最前面)"></a>对所有出现的字母进行组合(要将每个字符串的首字母放在最前面)</h1><pre><code>&gt;&gt;&gt; &apos;&apos;.join(first_letters)
&apos;OHIS&apos;
&gt;&gt;&gt; unique_characters - first_letters
{&apos;D&apos;, &apos;E&apos;, &apos;A&apos;, &apos;T&apos;, &apos;W&apos;}
&gt;&gt;&gt; &apos;&apos;.join(unique_characters - first_letters)
&apos;DEATW&apos;
&gt;&gt;&gt; &apos;&apos;.join(first_letters) + &apos;&apos;.join(unique_characters - first_letters)&apos;OHISDEATW
</code></pre><p><strong>解读</strong></p>
<ul>
<li>此处对所有出现的字母进行组合，因为要求“单词”不能以0开始，所以我们现在把这个开始的字母放在前面，为接下来的排除做准备</li>
</ul>
<h1 id="获取字母和数字对应的ASCII值"><a href="#获取字母和数字对应的ASCII值" class="headerlink" title="获取字母和数字对应的ASCII值"></a>获取字母和数字对应的ASCII值</h1><pre><code>&gt;&gt;&gt; ord(&apos;A&apos;)
65
&gt;&gt;&gt; ord(&apos;Z&apos;)
90
&gt;&gt;&gt; tuple(ord(c) for c in sorted_characters)
(79, 72, 73, 83, 68, 69, 65, 84, 87)
&gt;&gt;&gt; tuple(ord(c) for c in &apos;0123456789&apos;)
(48, 49, 50, 51, 52, 53, 54, 55, 56, 57)
&gt;&gt;&gt; digits[0]
48
</code></pre><p><strong>解读</strong></p>
<ul>
<li>ord()函数: 它以一个字符作为参数，返回对应的ASCII值</li>
<li>(ord(c) for c in sorted_characters) 是一个生成器表达式，最后将生成器表达式传给tuple()，生成器表达式类似一个yield值的匿名函数，返回迭代器。</li>
</ul>
<h1 id="对出现的所有数字可能的排列进行迭代"><a href="#对出现的所有数字可能的排列进行迭代" class="headerlink" title="对出现的所有数字可能的排列进行迭代"></a>对出现的所有数字可能的排列进行迭代</h1><pre><code> &gt;&gt;&gt; import itertools
&gt;&gt;&gt; perms = itertools.permutations(&apos;ABC&apos;, 3) 
&gt;&gt;&gt; list(itertools.permutations(&apos;ABC&apos;, 3)) 
[(&apos;A&apos;, &apos;B&apos;, &apos;C&apos;), (&apos;A&apos;, &apos;C&apos;, &apos;B&apos;),
 (&apos;B&apos;, &apos;A&apos;, &apos;C&apos;), (&apos;B&apos;, &apos;C&apos;, &apos;A&apos;),
 (&apos;C&apos;, &apos;A&apos;, &apos;B&apos;), (&apos;C&apos;, &apos;B&apos;, &apos;A&apos;)]
&gt;&gt;&gt; for guess in itertools.permutations(&apos;ABC&apos;, 3):
...     print(guess)
...     print(guess[:2])
... 
(&apos;A&apos;, &apos;B&apos;, &apos;C&apos;)
(&apos;A&apos;, &apos;B&apos;)
(&apos;A&apos;, &apos;C&apos;, &apos;B&apos;)
(&apos;A&apos;, &apos;C&apos;)
(&apos;B&apos;, &apos;A&apos;, &apos;C&apos;)
(&apos;B&apos;, &apos;A&apos;)
(&apos;B&apos;, &apos;C&apos;, &apos;A&apos;)
(&apos;B&apos;, &apos;C&apos;)
(&apos;C&apos;, &apos;A&apos;, &apos;B&apos;)
(&apos;C&apos;, &apos;A&apos;)
(&apos;C&apos;, &apos;B&apos;, &apos;A&apos;)
(&apos;C&apos;, &apos;B&apos;)
</code></pre><p><strong> 解读</strong></p>
<ul>
<li>permutations() 函数接受一个序列(这里是3个数字组成的列表) 和一个表示你要的排列的元素的数目的数字。函数返回迭代器，使用for循环对其进行迭代</li>
<li>guess[:2]将guess序列中进行切片操作，前两个元素返回一个新的序列</li>
</ul>
<h1 id="无数此的转换与匹配检验"><a href="#无数此的转换与匹配检验" class="headerlink" title="无数此的转换与匹配检验"></a>无数此的转换与匹配检验</h1><pre><code>&gt;&gt;&gt; zip([1,2,3],[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])
&lt;zip object at 0x7fb79d0d3ec8&gt;
&gt;&gt;&gt; list(zip(range(0, 3), range(10, 13)))
[(0, 10), (1, 11), (2, 12)]
&gt;&gt;&gt; dict(zip([1,2,3],[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]))
{1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;}
&gt;&gt;&gt; translation_table = {ord(&apos;A&apos;): ord(&apos;1&apos;)} 
&gt;&gt;&gt; translation_table 
{65: 49}
&gt;&gt;&gt; &apos;ABC&apos;.translate(translation_table) 
&apos;1BC&apos;
&gt;&gt;&gt; eval(&apos;1 + 1 == 2&apos;)
True
&gt;&gt;&gt; eval(&apos;1 + 1 == 3&apos;)
False
</code></pre><p><strong> 解读</strong></p>
<ul>
<li>zip()是Python的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）</li>
<li>dict()对zip函数返回的列表进行字典转换</li>
<li>translate():一个字符串的translate()方法接收一个转换表，并用它来转换该字符串。换句话说，它将出现在转换表的键中的字节替换为该键对应的值.这个例子里， 将ABC “翻译为” 1BC.</li>
<li>eval():Python 通用求值工具</li>
</ul>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><pre><code>import re
import itertools

def solve(puzzle):
    words = re.findall(&apos;[A-Z]+&apos;, puzzle.upper())
    unique_characters = set(&apos;&apos;.join(words))
    assert len(unique_characters) &lt;= 10, &apos;Too many letters&apos;
    first_letters = {word[0] for word in words}
    n = len(first_letters)
    sorted_characters = &apos;&apos;.join(first_letters) + \
    &apos;&apos;.join(unique_characters - first_letters)
    characters = tuple(ord(c) for c in sorted_characters)
    digits = tuple(ord(c) for c in &apos;0123456789&apos;)
    zero = digits[0]
    for guess in itertools.permutations(digits, len(characters)):
    if zero not in guess[:n]:
        equation = puzzle.translate(dict(zip(characters, guess)))
        if eval(equation):
            return equation

if __name__ == &apos;__main__&apos;:
    import sys
    for puzzle in sys.argv[1:]:
    print(puzzle)
    solution = solve(puzzle)
    if solution:
        print(solution)
</code></pre><p>try runing :  python3 alphametics.py “HAWAII + IDAHO + IOWA + OHIO == STATES”</p>
<p><strong>PS: 以后再也不写这样的文档了，别问我为啥、、@ - @</strong> </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;HAWAII + IDAHO + IOWA + OHIO == STATES&lt;br&gt;510199 + 98153 + 9301 + 3593 == 621246&lt;br&gt;What is this ？
&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="书籍阅读" scheme="www.magicroc.com/categories/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="Python" scheme="www.magicroc.com/tags/Python/"/>
    
      <category term="深入python3" scheme="www.magicroc.com/tags/%E6%B7%B1%E5%85%A5python3/"/>
    
  </entry>
  
  <entry>
    <title>利用github分支多电脑维护hexo</title>
    <link href="www.magicroc.com/2017/02/05/%E5%88%A9%E7%94%A8github%E5%88%86%E6%94%AF%E5%A4%9A%E7%94%B5%E8%84%91%E7%BB%B4%E6%8A%A4hexo/"/>
    <id>www.magicroc.com/2017/02/05/利用github分支多电脑维护hexo/</id>
    <published>2017-02-04T16:26:59.000Z</published>
    <updated>2017-03-13T13:51:32.463Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>hexo真心很好用，但是如果更换系统或者更换电脑后应该怎么继续维护这个博客呢，我使用了github pages，可以利用github的分支功能解决这个问题，一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。</strong></p>
</blockquote>
<a id="more"></a>
<p><img src="1.png" alt="配图"></p>
<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><pre><code>现在已经在一台电脑上搭建好hexo，并且已经部署到github pages，可以成功的发布博客
</code></pre><h1 id="新建分支提交原始文件"><a href="#新建分支提交原始文件" class="headerlink" title="新建分支提交原始文件"></a>新建分支提交原始文件</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在本地博客根目录输入<strong>git init</strong>，为整个hexo目录初始化git环境</p>
<h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>将本地与github上的仓库建立关联</p>
<pre><code>git remote add origin git@github.com:MagicRoc/MagicRoc.github.io.git
</code></pre><h2 id="建立新分支并切换到新分支"><a href="#建立新分支并切换到新分支" class="headerlink" title="建立新分支并切换到新分支"></a>建立新分支并切换到新分支</h2><p>新建分支hexo并切换到hexo分支</p>
<pre><code>git checkout -b hexo
</code></pre><h2 id="将hexo生成网站原始的文件提交到hexo分支"><a href="#将hexo生成网站原始的文件提交到hexo分支" class="headerlink" title="将hexo生成网站原始的文件提交到hexo分支"></a>将hexo生成网站原始的文件提交到hexo分支</h2><pre><code>git add -A
git commit -m &quot;原始文件&quot;
</code></pre><h2 id="将hexo分支推送到远程库"><a href="#将hexo分支推送到远程库" class="headerlink" title="将hexo分支推送到远程库"></a>将hexo分支推送到远程库</h2><pre><code>git push origin hexo
</code></pre><p><strong> 现在已经成功备份到hexo分支</strong></p>
<h1 id="换系统或者换电脑之后的hexo数据恢复"><a href="#换系统或者换电脑之后的hexo数据恢复" class="headerlink" title="换系统或者换电脑之后的hexo数据恢复"></a>换系统或者换电脑之后的hexo数据恢复</h1><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>首先在新环境下安装<strong>Node 、Git</strong></p>
<h3 id="Node安装"><a href="#Node安装" class="headerlink" title="Node安装"></a>Node安装</h3><p>升级系统，安装依赖包</p>
<pre><code>sudo apt-get update
sudo apt-get install python gcc make g++
</code></pre><p>获取源代码，解压</p>
<pre><code>wget http://nodejs.org/dist/v0.12.9/node-v0.12.9.tar.gz
tar zxvf node-v0.12.9.tar.gz
</code></pre><p>编译、安装</p>
<pre><code>cd node-v0.12.4/
./configure
sudo make install
</code></pre><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><pre><code>sudo apt-get install git
</code></pre><p>将本地SSH key添加到github，终端输入：</p>
<pre><code>ssh-keygen -t rsa -C &quot;fengyujiancheng@aliyun.com&quot;
</code></pre><p>然后将用户主目录中的.ssh目录下的id_rsa.pub文件内容复制，登陆GitHub，打开“Account settings”，“SSH Keys”页面：<br>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。</p>
<pre><code>最后不要忘记这两行命令

git config --global user.name &quot;MagicROC&quot;
git config --global user.email &quot;fengyujiancheng@aliyun.com&quot;
</code></pre><h2 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h2><p>克隆仓库</p>
<pre><code>git clone https://github.com/MagicRoc/MagicRoc.github.io.git
</code></pre><p>切换到hexo分支</p>
<pre><code>git checkout hexo
</code></pre><p>安装hexo</p>
<pre><code>npm install -g hexo-cli
</code></pre><p>安装依赖包</p>
<pre><code>npm install
</code></pre><p>安装git部署插件</p>
<pre><code>npm install hexo-deployer-git
</code></pre><p><strong> 不需要hexo init这条指令</strong></p>
<p>测试</p>
<pre><code>hexo g
hexo s
</code></pre><h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><p>在hexo分支下写好新博客后执行以下操作</p>
<pre><code>git add .
git commit -m &quot;...&quot;
git push origin hexo
</code></pre><p><strong>发布网站到master分支上</strong></p>
<pre><code>hexo g -d
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;hexo真心很好用，但是如果更换系统或者更换电脑后应该怎么继续维护这个博客呢，我使用了github pages，可以利用github的分支功能解决这个问题，一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="手段方法" scheme="www.magicroc.com/categories/%E6%89%8B%E6%AE%B5%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="github" scheme="www.magicroc.com/tags/github/"/>
    
      <category term="hexo" scheme="www.magicroc.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Python图片转字符画</title>
    <link href="www.magicroc.com/2017/02/03/Python%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB/"/>
    <id>www.magicroc.com/2017/02/03/Python图片转字符画/</id>
    <published>2017-02-03T05:16:09.000Z</published>
    <updated>2017-03-13T13:41:50.845Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>在网上偶然发现一篇使用python实现图片转字符画的文章，觉得很有创意，图片的处理使用PIL。于是尝试了一下，本篇博客主要是参考原文，百度谷歌后解决在实践中遇到的问题，和一些已经解答的疑惑。在此记录所得</strong></p>
</blockquote>
<a id="more"></a>
<p><img src="3.png" alt="配图"></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>一张彩色的照片有很多颜色，每种颜色都有对应的RGB值。我们可以这样处理一张图片，将照片深色的部分使用繁琐的字符填充，而浅色的部分使用简单的字符填充，例如” $ “ 和 “ . “两种字符填充可以组成强烈的对比。判断深色部分或者浅色部分使用灰度值</p>
<blockquote>
<p>灰度值：指黑白图像中点的颜色深度，范围一般从0到255，白色为255，黑色为0，故黑白图片也称灰度图像</p>
</blockquote>
<p>使用灰度值公式将像素的 RGB 值映射到灰度值:</p>
<pre><code>gray ＝ 0.2126 * r + 0.7152 * g + 0.0722 * b
</code></pre><p>这样就可以判断出照片中深色浅色的部位了，因为我们能使用的字符有限，没有办法一个灰度值使用一个字符替代，所以使用一种字符替换三个相近灰度值的部分，我们可以使用”$”字符替代灰度值为0、1、2黑色的部分，用”.”字符替代灰度值为251、252、253的部分，而254、255这样白色的使用空字符 “ “</p>
<h1 id="安装pillow-PIL-库"><a href="#安装pillow-PIL-库" class="headerlink" title="安装pillow(PIL)库:"></a>安装pillow(PIL)库:</h1><pre><code>$ sudo apt-get update
$ sudo apt-get install python-dev
$ sudo apt-get install libtiff5-dev libjpeg8-dev zlib1g-dev libfreetype6-dev liblcms2-dev libwebp-dev tcl8.6-dev tk8.6-dev python-tk
$ sudo pip install pillow
</code></pre><h1 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h1><h2 id="导入的库"><a href="#导入的库" class="headerlink" title="导入的库"></a>导入的库</h2><pre><code>from PIL import Image
import argparse

parser = argparse.ArgumentParser()

parser.add_argument(&apos;file&apos;)     #输入文件
parser.add_argument(&apos;-o&apos;, &apos;--output&apos;)   #输出文件
parser.add_argument(&apos;--width&apos;, type = int, default = 80) #输出字符画宽
parser.add_argument(&apos;--height&apos;, type = int, default = 80) #输出字符画高
</code></pre><p>图片的处理使用PIL库中的image<br>argpase 是解析命令行参数和选择的模块，如需了解，百度谷歌</p>
<h2 id="用于替换图片的字符列表："><a href="#用于替换图片的字符列表：" class="headerlink" title="用于替换图片的字符列表："></a>用于替换图片的字符列表：</h2><pre><code>ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~&lt;&gt;i!lI;:,\&quot;^`&apos;. &quot;)
</code></pre><h2 id="RGB值转换字符的函数"><a href="#RGB值转换字符的函数" class="headerlink" title="RGB值转换字符的函数"></a>RGB值转换字符的函数</h2><pre><code>def get_char(r,g,b,alpha = 256):
    if alpha == 0:
    return &apos; &apos;
    length = len(ascii_char)
    gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b)

    unit = (256.0 + 1)/length
    return ascii_char[int(gray/unit)]
</code></pre><p>注意几个灰度值共用一个字符</p>
<h2 id="使用Image处理图片"><a href="#使用Image处理图片" class="headerlink" title="使用Image处理图片"></a>使用Image处理图片</h2><pre><code>im = Image.open(IMG)
im = im.resize((WIDTH,HEIGHT), Image.NEAREST)
</code></pre><p>image.open(),打开相应的照片，并返回一对象<br>resize()函数处理图片的缩放，WIDTH，HEIGHT则是缩放后的宽高，NEAREST则是缩放的质量，此处是最低质量<br><strong>（ PIL.Image.NEAREST：最低质量， PIL.Image.BILINEAR：双线性，<br>PIL.Image.BICUBIC：三次样条插值，Image.ANTIALIAS：最高质量）</strong></p>
<h2 id="生成表示字符画的字符串"><a href="#生成表示字符画的字符串" class="headerlink" title="生成表示字符画的字符串"></a>生成表示字符画的字符串</h2><pre><code>for i in range(HEIGHT):
    for j in range(WIDTH):
        txt += get_char(*im.getpixel((j,i)))
    txt += &apos;\n&apos;
</code></pre><p><strong>im.getpixel(xy) 返回给定位置的像素值。返回一个含有r,g,b三个值的元组<br>注意元组前面加*号传入Python函数时，元组中的元素被解开作为独立的参数依次传给python函数</strong></p>
<h1 id="完整参考代码"><a href="#完整参考代码" class="headerlink" title="完整参考代码"></a>完整参考代码</h1><pre><code> from PIL import Image
import argparse


parser = argparse.ArgumentParser() #命令行输入参数处理

parser.add_argument(&apos;file&apos;)     #输入文件
parser.add_argument(&apos;-o&apos;, &apos;--output&apos;)   #输出文件
parser.add_argument(&apos;--width&apos;, type = int, default = 80) #输出字符画宽
parser.add_argument(&apos;--height&apos;, type = int, default = 80) #输出字符画高


args = parser.parse_args() #获取参数

IMG = args.file
WIDTH = args.width
HEIGHT = args.height
OUTPUT = args.output

ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~&lt;&gt;i!lI;:,\&quot;^`&apos;. &quot;)


def get_char(r,g,b,alpha = 256): # 将256灰度映射到70个字符上
    if alpha == 0:
    return &apos; &apos;
    length = len(ascii_char)
    gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b)

    unit = (256.0 + 1)/length
    return ascii_char[int(gray/unit)]

if __name__ == &apos;__main__&apos;:

    im = Image.open(IMG)
    im = im.resize((WIDTH,HEIGHT), Image.NEAREST)

    txt = &quot;&quot;

    for i in range(HEIGHT):
    for j in range(WIDTH):
        txt += get_char(*im.getpixel((j,i)))
    txt += &apos;\n&apos;

    print txt


    if OUTPUT:     #字符画输出到文件
    with open(OUTPUT,&apos;w&apos;) as f:
        f.write(txt)
    else:
    with open(&quot;output.txt&quot;,&apos;w&apos;) as f:
        f.write(txt)
</code></pre><h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><p>默认输出文件名output.txt，图片默认高宽80</p>
<pre><code>python image_ascii.py image.jpg
</code></pre><p>也可以这样制定输出文件名和高宽</p>
<pre><code>python image_ascii.py image.jpg -o put.txt --width 40 --height 40
</code></pre><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><pre><code>自己的照片对应的字符画
</code></pre><p><img src="1.png" alt="效果图"><br>    网上找的卡通照片原图以及对应的字符画<br><img src="0.jpg" alt="效果图">  <img src="2.png" alt="效果图">    </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;在网上偶然发现一篇使用python实现图片转字符画的文章，觉得很有创意，图片的处理使用PIL。于是尝试了一下，本篇博客主要是参考原文，百度谷歌后解决在实践中遇到的问题，和一些已经解答的疑惑。在此记录所得&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术研究" scheme="www.magicroc.com/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Python" scheme="www.magicroc.com/tags/Python/"/>
    
      <category term="PIL" scheme="www.magicroc.com/tags/PIL/"/>
    
  </entry>
  
  <entry>
    <title>Flask-admin使用经验技巧总结</title>
    <link href="www.magicroc.com/2017/01/22/Flask-admin%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <id>www.magicroc.com/2017/01/22/Flask-admin使用经验技巧总结/</id>
    <published>2017-01-22T11:06:24.000Z</published>
    <updated>2017-03-13T13:58:39.757Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>前段时间自学了Flask框架，看得狗书入门，最近做一个新闻发布网站准备拿Flask来做，尝试一下Flask快速开发，并且练练手，于是接触到了Flask-admin。<br>总结一下Flask-admin</strong></p>
</blockquote>
<a id="more"></a>
<p><img src="3.png" alt="配图"></p>
<h1 id="首先需要导入的包"><a href="#首先需要导入的包" class="headerlink" title="首先需要导入的包"></a>首先需要导入的包</h1><pre><code>from flask_admin import Admin,BaseView,expose,AdminIndexView
from flask_admin.contrib.sqla import ModelView
</code></pre><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="1.png" alt="效果图"></p>
<h1 id="模型视图"><a href="#模型视图" class="headerlink" title="模型视图"></a>模型视图</h1><ul>
<li><p>管理新闻、管理公告、管理文件、管理展示栏是四个与数据库表同步的模型视图，如果你想要在后台管理程序中数据库中的表在初始化admin后仅需一句代码</p>
<pre><code>admin = Admin(app)
admin.add_view(ModelView(User, db.session))&apos;
</code></pre></li>
<li><p>但是有时候flask-admin的默认设置并不能满足你的条件，如果我们在后台只打算让表中固定的几列数据显示,这时候我们就不能直接像上面那样直接ModelView，我们需自定义一个类并继承ModelView，并重写一些代码，把想要显示出来的列名写在column_list中</p>
<pre><code>class MyV1(ModelView):
        column_list = (&apos;id&apos;, &apos;title&apos;,&apos;timestamp&apos;,&apos;count&apos;,&apos;content&apos;)
        def __init__(self, session, **kwargs):
        super(MyV1, self).__init__(News, session, **kwargs)
</code></pre></li>
</ul>
<p>然后在程序中再加入代码如下，然后就OK了</p>
<pre><code>admin.add_view(MyV1(db.session,name = u&apos;管理新闻&apos;))
</code></pre><ul>
<li><p>如果我们使用flask做网站是给自己使用，后台和数据库中同步的列名是英文显示没有多大影响，自己写的数据库难道还不知道什么意思，但是当我们是写给非技术人员使用时，他们可能不能理解每个列名是什么意思，所以现在我们就需要将列名中文化，也是需要重写column_labels</p>
<pre><code>class MyV1(ModelView):
    column_labels = {
    &apos;id&apos;:u&apos;序号&apos;,
    &apos;title&apos; : u&apos;新闻标题&apos;,
    &apos;timestamp&apos;:u&apos;发布时间&apos;,
    &apos;count&apos;:u&apos;浏览次数&apos;,
    &apos;content&apos;:u&apos;新闻内容&apos;
    }
    column_list = (&apos;id&apos;, &apos;title&apos;,&apos;timestamp&apos;,&apos;count&apos;,&apos;content&apos;)
    def __init__(self, session, **kwargs):
    super(MyV1, self).__init__(News, session, **kwargs)
</code></pre></li>
</ul>
<ul>
<li>有时候当同步数据库表成功后，扩展会有一个默认新建数据插入数据库表中的功能，但是我们有时候发表博客、新闻这些需要排版的文章但是默认的新建数据不支持这个功能怎么办，我们可以把默认创建功能先关掉。</li>
</ul>
<pre><code>class MyV1(ModelView):
    can_create = False

    column_labels = {
    &apos;id&apos;:u&apos;序号&apos;,
    &apos;title&apos; : u&apos;新闻标题&apos;,
    &apos;timestamp&apos;:u&apos;发布时间&apos;,
    &apos;count&apos;:u&apos;浏览次数&apos;,
    &apos;content&apos;:u&apos;新闻内容&apos;
    }
    column_list = (&apos;id&apos;, &apos;title&apos;,&apos;timestamp&apos;,&apos;count&apos;,&apos;content&apos;)
    def __init__(self, session, **kwargs):
    super(MyV1, self).__init__(News, session, **kwargs)
</code></pre><h1 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h1><ul>
<li><p>上面我们说到讲默认创建功能关掉，但是我们怎么新建数据呢，我们可以自己写一个视图，关联自己的模板，再在模板中集成富文本。</p>
<pre><code>class MyNews(BaseView):
      @expose(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])
        def index(self):
        form = NameForm()
        return self.render(&apos;donews.html&apos;, form=form)
</code></pre></li>
</ul>
<p>　　然后再程序中加入代码</p>
<pre><code>admin.add_view(MyNews(name=u&apos;发表新闻&apos;))
</code></pre><h1 id="对主页面的修改"><a href="#对主页面的修改" class="headerlink" title="对主页面的修改"></a>对主页面的修改</h1><ul>
<li><p>Flask-admin默认主页面标题是Home，而且界面一片空白，由于各种需要，我们需要对这些进行更改，参考以下代码<br>复制代码</p>
<pre><code>admin = Admin(
    app,
    index_view=AdminIndexView(
    name=&apos;导航栏&apos;,
    template=&apos;welcome.html&apos;,
    url=&apos;/admin&apos;
    )
)
</code></pre></li>
</ul>
<p>将标题修改为导航栏，并将主页设置为welcome.html，进入后台对应的url也可以修改</p>
<h1 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h1><ul>
<li><p>一般后台并不是对所有用户开放的，所有牵扯到了管理员权限，这一块我是依靠flask-login这个扩展实现的，关于flask-login会再写一遍进行总结，新加代码如下</p>
<pre><code>class MyNews(BaseView):
    def is_accessible(self):
    if current_user.is_authenticated and current_user.username == &quot;admin&quot;:
        return True
    return False
    @expose(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])
    def index(self):
    form = NameForm()
    return self.render(&apos;donews.html&apos;, form=form)
</code></pre></li>
</ul>
<p>通过判断当前用户登录状态和当前登录的用户名进行权限设置</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;前段时间自学了Flask框架，看得狗书入门，最近做一个新闻发布网站准备拿Flask来做，尝试一下Flask快速开发，并且练练手，于是接触到了Flask-admin。&lt;br&gt;总结一下Flask-admin&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术研究" scheme="www.magicroc.com/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Flask" scheme="www.magicroc.com/tags/Flask/"/>
    
      <category term="Flask-admin" scheme="www.magicroc.com/tags/Flask-admin/"/>
    
  </entry>
  
</feed>
